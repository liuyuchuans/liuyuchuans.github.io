{"version":3,"sources":["webpack:///./node_modules/_echarts@4.1.0@echarts/lib/component/radiusAxis.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/chart/line/LineView.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/chart/helper/SymbolDraw.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/processor/dataSample.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/coord/polar/AngleAxis.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/chart/line/lineAnimationDiff.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/chart/line/poly.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/coord/polar/PolarModel.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/component/axis/AngleAxisView.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/chart/line/helper.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/coord/polar/AxisModel.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/component/polar.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/component/angleAxis.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/layout/points.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/chart/line.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/chart/helper/Symbol.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/chart/line/LineSeries.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/layout/barPolar.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/coord/polar/polarCreator.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/coord/polar/RadiusAxis.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/component/axis/RadiusAxisView.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/visual/symbol.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/coord/polar/Polar.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/component/axisPointer/PolarAxisPointer.js","webpack:///src/view/ECharts/EChartsOne.vue","webpack:///./src/view/ECharts/EChartsOne.vue?1cad","webpack:///./src/view/ECharts/EChartsOne.vue"],"names":["__webpack_require__","__DEV__","zrUtil","SymbolDraw","SymbolClz","lineAnimationDiff","graphic","modelUtil","_poly","Polyline","Polygon","ChartView","round","_helper","prepareDataCoordInfo","getStackedOnPoint","isPointsSame","points1","points2","length","i","p1","p2","getSmooth","smooth","getAxisExtentWithGap","axis","extent","getGlobalExtent","onBand","halfBandWidth","getBandWidth","dir","createClipShape","coordSys","hasAnimation","forSymbol","seriesModel","type","polar","angleAxis","getAngleAxis","radiusExtent","getRadiusAxis","getExtent","slice","reverse","angleExtent","RADIAN","Math","PI","clipPath","Sector","shape","cx","cy","r0","r","startAngle","endAngle","clockwise","inverse","initProps","createPolarClipShape","cartesian","xExtent","getAxis","yExtent","isHorizontal","getBaseAxis","x","min","y","width","max","height","lineWidth","get","expandSize","Rect","createGridClipShape","turnPointsIntoStep","points","stepTurnAt","baseAxis","baseIndex","dim","stepPoints","nextPt","pt","push","stepPt","middle","stepPt2","getIsIgnoreFunc","data","showAllSymbol","isAuto","categoryAxis","getAxesByScale","axisExtent","availSize","abs","scale","count","isNaN","dataLen","step","dataIndex","getSymbolSize","canShowAllSymbolForCategory","categoryDataDim","mapDimension","labelMap","each","getViewLabels","labelItem","tickValue","hasOwnProperty","_default","extend","init","lineGroup","Group","symbolDraw","this","group","add","_symbolDraw","_lineGroup","render","ecModel","api","coordinateSystem","getData","lineStyleModel","getModel","areaStyleModel","mapArray","getItemLayout","isCoordSysPolar","prevCoordSys","_coordSys","polyline","_polyline","polygon","_polygon","isAreaChart","isEmpty","valueOrigin","stackedOnPoints","dataCoordInfo","valueDim","idx","len","getStackedOnPoints","showSymbol","isIgnoreFunc","oldData","_data","eachItemGraphicEl","el","__temp","remove","setItemGraphicEl","_step","_newPolygon","setClipPath","updateData","isIgnore","clipShape","stopAnimation","_stackedOnPoints","_points","_updateAnimation","setShape","_newPolyline","visualColor","visualMetaList","getVisual","coordDim","visualMeta","dimIndex","dimension","dimName","dimensions","dimInfo","getDimensionInfo","colorStops","map","stops","stop","coord","toGlobalCoord","dataToCoord","value","color","stopLen","outerColors","minCoord","maxCoord","coordSpan","offset","unshift","gradient","LinearGradient","getVisualGradient","useStyle","defaults","getLineStyle","fill","stroke","lineJoin","smoothMonotone","connectNulls","stackedOnSeries","getCalculationInfo","stackedOnSmooth","getAreaStyle","opacity","_valueOrigin","dispose","highlight","payload","queryDataIndex","Array","symbol","getItemGraphicEl","position","setZ","ignore","stopSymbolAnimation","prototype","call","downplay","silent","z2","hostModel","diff","current","stackedOnCurrent","next","stackedOnNext","__points","updateProps","updatedDataInfo","diffStatus","status","cmd","idx1","ptIdx","animators","during","attr","removeAll","module","exports","isObject","symbolCtor","_symbolCtor","symbolDrawProto","symbolNeedsDraw","point","opt","contain","getItemVisual","normalizeUpdateOpt","makeSeriesScope","itemStyle","getItemStyle","hoverItemStyle","symbolRotate","symbolOffset","hoverAnimation","labelModel","hoverLabelModel","cursorStyle","SymbolCtor","seriesScope","newIdx","symbolEl","update","oldIdx","fadeOut","execute","isPersistent","updateLayout","incrementalPrepareUpdate","_seriesScope","incrementalUpdate","taskParams","updateIncrementalAndHover","isGroup","incremental","useHoverLayer","start","end","traverse","enableAnimation","samplers","average","frame","sum","NaN","Infinity","isFinite","nearest","indexSampler","seriesType","modifyOutputEnd","reset","sampling","sampler","valueAxis","getOtherAxis","size","rate","setData","downSample","Axis","AngleAxis","constructor","pointToData","clamp","dataToAngle","angleToData","coordToData","inherits","newData","oldStackedOnPoints","newStackedOnPoints","oldCoordSys","newCoordSys","oldValueOrigin","newValueOrigin","diffResult","diffData","currPoints","nextPoints","currStackedPoints","nextStackedPoints","sortedIndices","rawIndices","newDataOldCoordInfo","oldDataNewCoordInfo","diffItem","pointAdded","currentPt","getRawIndex","dataToPoint","dataDimsForPoint","rawIndex","sort","a","b","sortedCurrPoints","sortedNextPoints","sortedCurrStackedPoints","sortedNextStackedPoints","sortedStatus","Path","vec2","fixClipWithShadow","vec2Min","vec2Max","scaleAndAdd","v2Copy","copy","v","cp0","cp1","isPointNull","p","drawSegment","ctx","segLen","allLen","smoothMin","smoothMax","prevIdx","k","prevP","ctrlLen","bezierCurveTo","lineTo","apply","arguments","nextIdx","nextP","ratioNextSeg","lenPrevSeg","lenNextSeg","sub","dist","getBoundingBox","smoothConstraint","ptMin","ptMax","style","brush","buildPath","result","bbox","stackedOnBBox","closePath","echarts","extendComponentModel","dependencies","findAxisModel","axisType","foundAxisModel","eachComponent","axisModel","getCoordSysModel","defaultOption","zlevel","z","center","radius","Model","elementList","getAxisLineShape","rExtent","angle","coordToPoint","x1","y1","x2","y2","getRadiusIdx","fixAngleOverlap","list","firstItem","lastItem","pop","axisPointerClass","angleAxisModel","ticksAngles","getTicksCoords","labels","clone","name","isBlank","_axisLine","circle","Circle","_axisTick","tickModel","tickLen","lines","tickAngleItem","Line","mergePath","_axisLabel","rawCategoryData","getCategories","commonLabelModel","labelMargin","labelTextAlign","labelTextVerticalAlign","textStyle","textEl","Text","setTextStyle","textFill","getTextColor","text","formattedLabel","textAlign","textVerticalAlign","_splitLine","lineColors","lineCount","splitLines","colorIndex","_splitArea","areaColors","splitAreas","prevAngle","r1","isDimensionStacked","stacked","valueStart","getValueStart","baseAxisDim","valueAxisDim","baseDim","baseDataOffset","dims","stackResultDim","stackedOverDimension","stackedData","ComponentModel","axisModelCreator","axisModelCommonMixin","PolarAxisModel","queryComponents","mainType","index","option","polarIndex","id","polarId","merge","polarAxisDefaultExtendedOption","splitNumber","getAxisType","axisDim","axisLabel","rotate","barPolar","registerLayout","curry","extendComponentView","createRenderPlanner","plan","isLargeRender","pipelineContext","large","dimLen","progress","params","segCount","Float32Array","tmpIn","tmpOut","setItemLayout","setLayout","visualSymbol","layoutPoints","dataSample","registerVisual","registerProcessor","PRIORITY","PROCESSOR","STATISTIC","createSymbol","parsePercent","getDefaultLabel","symbolProto","symbolSize","getScale","driftSymbol","dx","dy","parent","drift","_createSymbol","symbolType","keepAspect","symbolPath","culling","_symbolType","toLastFrame","childAt","getSymbolPath","trigger","setDraggable","draggable","cursor","isInit","_updateCommon","fadeIn","target","_seriesModel","normalStyleAccessPath","emphasisStyleAccessPath","normalLabelAccessPath","emphasisLabelAccessPath","strokeNoScale","hasItemOption","itemModel","getItemModel","getShallow","elStyle","setColor","symbolInnerColor","setStyle","liftZ","z2Origin","__z2Origin","useNameLabel","setLabelStyle","labelFetcher","labelDataIndex","defaultText","getName","isRectText","autoColor","off","hoverStyle","setHoverStyle","isAnimationEnabled","onEmphasis","ratio","animateTo","onNormal","on","cb","keepLabel","createListFromArray","getInitialData","getSource","legendHoverLink","clipOverflow","label","lineStyle","animationEasing","progressive","hoverLayerThreshold","getSeriesStackId","seriesIndex","getAxisKey","getWidth","getHeight","lastStackCoords","barWidthAndOffset","barSeries","columnsMap","bandWidth","columnsOnAxis","remainedWidth","autoWidthCount","categoryGap","gap","stacks","stackId","maxWidth","barWidth","barMaxWidth","barGap","barCategoryGap","coordSysName","barGapPercent","autoWidth","column","stack","lastColumn","widthSum","calRadialBar","filter","getSeriesByType","isSeriesFiltered","eachSeriesByType","columnLayoutInfo","columnOffset","columnWidth","barMinHeight","barMinAngle","valueAxisStart","baseValue","sign","baseCoord","n","radiusSpan","dataToRadius","angleSpan","Polar","_axisHelper","createScaleByModel","niceScaleExtent","CoordinateSystem","getStackedDimension","updatePolarScale","radiusAxis","setExtent","eachSeries","unionExtentFromData","model","setAxis","polarCreator","create","polarList","polarModel","radiusAxisModel","resizePolar","register","RadiusAxis","radiusToData","AxisBuilder","axisBuilderAttrs","selfBuilderAttrs","ticksCoords","axisAngle","layout","rotation","labelDirection","tickDirection","nameDirection","labelRotate","layoutAxis","axisBuilder","getGroup","prevRadius","defaultSymbolType","legendSymbol","performRawSeries","setVisual","symbolKeepAspect","hasCallback","dataEach","rawValue","getRawValue","getDataParams","setItemVisual","itemSymbolType","itemSymbolSize","itemSymbolKeepAspect","_radiusAxis","_angleAxis","axisPointerEnabled","containPoint","pointToCoord","containData","getAxes","scaleType","axes","getTooltipAxes","baseAxes","otherAxes","minAngle","maxAngle","sqrt","radian","atan2","cos","sin","formatUtil","BaseAxisPointer","viewHelper","matrix","AxisView","PolarAxisPointer","makeElOption","elOption","axisPointerModel","animationThreshold","coordValue","otherExtent","capitalFirst","axisPointerType","buildElStyle","pointerOption","pointerShapeBuilder","graphicKey","pointer","labelPos","align","verticalAlign","transform","translate","applyTransform","labelRotation","labelLayout","innerTextLayout","getLabelPosition","buildLabelElOption","line","makeLineShape","shadow","makeSectorShape","registerAxisPointerClass","EChartsOne","components","v-chart","ECharts","t","title","legend","tooltip","axisPointer","series","animationDuration","ECharts_EChartsOne","_h","$createElement","_self","_c","attrs","options","staticRenderFns","Component","normalizeComponent","ssrContext","__webpack_exports__"],"mappings":"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","file":"static/js/0.c9c6d03845d31ed02c53.js","sourcesContent":["require(\"../coord/polar/polarCreator\");\n\nrequire(\"./axis/RadiusAxisView\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_echarts@4.1.0@echarts/lib/component/radiusAxis.js\n// module id = +hCq\n// module chunks = 0","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar SymbolDraw = require(\"../helper/SymbolDraw\");\n\nvar SymbolClz = require(\"../helper/Symbol\");\n\nvar lineAnimationDiff = require(\"./lineAnimationDiff\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar _poly = require(\"./poly\");\n\nvar Polyline = _poly.Polyline;\nvar Polygon = _poly.Polygon;\n\nvar ChartView = require(\"../../view/Chart\");\n\nvar _number = require(\"../../util/number\");\n\nvar round = _number.round;\n\nvar _helper = require(\"./helper\");\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// FIXME step not support polar\nfunction isPointsSame(points1, points2) {\n  if (points1.length !== points2.length) {\n    return;\n  }\n\n  for (var i = 0; i < points1.length; i++) {\n    var p1 = points1[i];\n    var p2 = points2[i];\n\n    if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n      return;\n    }\n  }\n\n  return true;\n}\n\nfunction getSmooth(smooth) {\n  return typeof smooth === 'number' ? smooth : smooth ? 0.5 : 0;\n}\n\nfunction getAxisExtentWithGap(axis) {\n  var extent = axis.getGlobalExtent();\n\n  if (axis.onBand) {\n    // Remove extra 1px to avoid line miter in clipped edge\n    var halfBandWidth = axis.getBandWidth() / 2 - 1;\n    var dir = extent[1] > extent[0] ? 1 : -1;\n    extent[0] += dir * halfBandWidth;\n    extent[1] -= dir * halfBandWidth;\n  }\n\n  return extent;\n}\n/**\n * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n * @param {module:echarts/data/List} data\n * @param {Object} dataCoordInfo\n * @param {Array.<Array.<number>>} points\n */\n\n\nfunction getStackedOnPoints(coordSys, data, dataCoordInfo) {\n  if (!dataCoordInfo.valueDim) {\n    return [];\n  }\n\n  var points = [];\n\n  for (var idx = 0, len = data.count(); idx < len; idx++) {\n    points.push(getStackedOnPoint(dataCoordInfo, coordSys, data, idx));\n  }\n\n  return points;\n}\n\nfunction createGridClipShape(cartesian, hasAnimation, forSymbol, seriesModel) {\n  var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n  var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n  var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n  var x = Math.min(xExtent[0], xExtent[1]);\n  var y = Math.min(yExtent[0], yExtent[1]);\n  var width = Math.max(xExtent[0], xExtent[1]) - x;\n  var height = Math.max(yExtent[0], yExtent[1]) - y; // Avoid float number rounding error for symbol on the edge of axis extent.\n  // See #7913 and `test/dataZoom-clip.html`.\n\n  if (forSymbol) {\n    x -= 0.5;\n    width += 0.5;\n    y -= 0.5;\n    height += 0.5;\n  } else {\n    var lineWidth = seriesModel.get('lineStyle.width') || 2; // Expand clip shape to avoid clipping when line value exceeds axis\n\n    var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n\n    if (isHorizontal) {\n      y -= expandSize;\n      height += expandSize * 2;\n    } else {\n      x -= expandSize;\n      width += expandSize * 2;\n    }\n  }\n\n  var clipPath = new graphic.Rect({\n    shape: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n    graphic.initProps(clipPath, {\n      shape: {\n        width: width,\n        height: height\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createPolarClipShape(polar, hasAnimation, forSymbol, seriesModel) {\n  var angleAxis = polar.getAngleAxis();\n  var radiusAxis = polar.getRadiusAxis();\n  var radiusExtent = radiusAxis.getExtent().slice();\n  radiusExtent[0] > radiusExtent[1] && radiusExtent.reverse();\n  var angleExtent = angleAxis.getExtent();\n  var RADIAN = Math.PI / 180; // Avoid float number rounding error for symbol on the edge of axis extent.\n\n  if (forSymbol) {\n    radiusExtent[0] -= 0.5;\n    radiusExtent[1] += 0.5;\n  }\n\n  var clipPath = new graphic.Sector({\n    shape: {\n      cx: round(polar.cx, 1),\n      cy: round(polar.cy, 1),\n      r0: round(radiusExtent[0], 1),\n      r: round(radiusExtent[1], 1),\n      startAngle: -angleExtent[0] * RADIAN,\n      endAngle: -angleExtent[1] * RADIAN,\n      clockwise: angleAxis.inverse\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: -angleExtent[1] * RADIAN\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createClipShape(coordSys, hasAnimation, forSymbol, seriesModel) {\n  return coordSys.type === 'polar' ? createPolarClipShape(coordSys, hasAnimation, forSymbol, seriesModel) : createGridClipShape(coordSys, hasAnimation, forSymbol, seriesModel);\n}\n\nfunction turnPointsIntoStep(points, coordSys, stepTurnAt) {\n  var baseAxis = coordSys.getBaseAxis();\n  var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n  var stepPoints = [];\n\n  for (var i = 0; i < points.length - 1; i++) {\n    var nextPt = points[i + 1];\n    var pt = points[i];\n    stepPoints.push(pt);\n    var stepPt = [];\n\n    switch (stepTurnAt) {\n      case 'end':\n        stepPt[baseIndex] = nextPt[baseIndex];\n        stepPt[1 - baseIndex] = pt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n        break;\n\n      case 'middle':\n        // default is start\n        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n        var stepPt2 = [];\n        stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n        stepPt[1 - baseIndex] = pt[1 - baseIndex];\n        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n        stepPoints.push(stepPt);\n        stepPoints.push(stepPt2);\n        break;\n\n      default:\n        stepPt[baseIndex] = pt[baseIndex];\n        stepPt[1 - baseIndex] = nextPt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n    }\n  } // Last points\n\n\n  points[i] && stepPoints.push(points[i]);\n  return stepPoints;\n}\n\nfunction getVisualGradient(data, coordSys) {\n  var visualMetaList = data.getVisual('visualMeta');\n\n  if (!visualMetaList || !visualMetaList.length || !data.count()) {\n    // When data.count() is 0, gradient range can not be calculated.\n    return;\n  }\n\n  if (coordSys.type !== 'cartesian2d') {\n    return;\n  }\n\n  var coordDim;\n  var visualMeta;\n\n  for (var i = visualMetaList.length - 1; i >= 0; i--) {\n    var dimIndex = visualMetaList[i].dimension;\n    var dimName = data.dimensions[dimIndex];\n    var dimInfo = data.getDimensionInfo(dimName);\n    coordDim = dimInfo && dimInfo.coordDim; // Can only be x or y\n\n    if (coordDim === 'x' || coordDim === 'y') {\n      visualMeta = visualMetaList[i];\n      break;\n    }\n  }\n\n  if (!visualMeta) {\n    return;\n  } // If the area to be rendered is bigger than area defined by LinearGradient,\n  // the canvas spec prescribes that the color of the first stop and the last\n  // stop should be used. But if two stops are added at offset 0, in effect\n  // browsers use the color of the second stop to render area outside\n  // LinearGradient. So we can only infinitesimally extend area defined in\n  // LinearGradient to render `outerColors`.\n\n\n  var axis = coordSys.getAxis(coordDim); // dataToCoor mapping may not be linear, but must be monotonic.\n\n  var colorStops = zrUtil.map(visualMeta.stops, function (stop) {\n    return {\n      coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),\n      color: stop.color\n    };\n  });\n  var stopLen = colorStops.length;\n  var outerColors = visualMeta.outerColors.slice();\n\n  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {\n    colorStops.reverse();\n    outerColors.reverse();\n  }\n\n  var tinyExtent = 10; // Arbitrary value: 10px\n\n  var minCoord = colorStops[0].coord - tinyExtent;\n  var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;\n  var coordSpan = maxCoord - minCoord;\n\n  if (coordSpan < 1e-3) {\n    return 'transparent';\n  }\n\n  zrUtil.each(colorStops, function (stop) {\n    stop.offset = (stop.coord - minCoord) / coordSpan;\n  });\n  colorStops.push({\n    offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,\n    color: outerColors[1] || 'transparent'\n  });\n  colorStops.unshift({\n    // notice colorStops.length have been changed.\n    offset: stopLen ? colorStops[0].offset : 0.5,\n    color: outerColors[0] || 'transparent'\n  }); // zrUtil.each(colorStops, function (colorStop) {\n  //     // Make sure each offset has rounded px to avoid not sharp edge\n  //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n  // });\n\n  var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);\n  gradient[coordDim] = minCoord;\n  gradient[coordDim + '2'] = maxCoord;\n  return gradient;\n}\n\nfunction getIsIgnoreFunc(seriesModel, data, coordSys) {\n  var showAllSymbol = seriesModel.get('showAllSymbol');\n  var isAuto = showAllSymbol === 'auto';\n\n  if (showAllSymbol && !isAuto) {\n    return;\n  }\n\n  var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n\n  if (!categoryAxis) {\n    return;\n  } // Note that category label interval strategy might bring some weird effect\n  // in some scenario: users may wonder why some of the symbols are not\n  // displayed. So we show all symbols as possible as we can.\n\n\n  if (isAuto // Simplify the logic, do not determine label overlap here.\n  && canShowAllSymbolForCategory(categoryAxis, data)) {\n    return;\n  } // Otherwise follow the label interval strategy on category axis.\n\n\n  var categoryDataDim = data.mapDimension(categoryAxis.dim);\n  var labelMap = {};\n  zrUtil.each(categoryAxis.getViewLabels(), function (labelItem) {\n    labelMap[labelItem.tickValue] = 1;\n  });\n  return function (dataIndex) {\n    return !labelMap.hasOwnProperty(data.get(categoryDataDim, dataIndex));\n  };\n}\n\nfunction canShowAllSymbolForCategory(categoryAxis, data) {\n  // In mose cases, line is monotonous on category axis, and the label size\n  // is close with each other. So we check the symbol size and some of the\n  // label size alone with the category axis to estimate whether all symbol\n  // can be shown without overlap.\n  var axisExtent = categoryAxis.getExtent();\n  var availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis.scale.count();\n  isNaN(availSize) && (availSize = 0); // 0/0 is NaN.\n  // Sampling some points, max 5.\n\n  var dataLen = data.count();\n  var step = Math.max(1, Math.round(dataLen / 5));\n\n  for (var dataIndex = 0; dataIndex < dataLen; dataIndex += step) {\n    if (SymbolClz.getSymbolSize(data, dataIndex // Only for cartesian, where `isHorizontal` exists.\n    )[categoryAxis.isHorizontal() ? 1 : 0] // Empirical number\n    * 1.5 > availSize) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar _default = ChartView.extend({\n  type: 'line',\n  init: function () {\n    var lineGroup = new graphic.Group();\n    var symbolDraw = new SymbolDraw();\n    this.group.add(symbolDraw.group);\n    this._symbolDraw = symbolDraw;\n    this._lineGroup = lineGroup;\n  },\n  render: function (seriesModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var group = this.group;\n    var data = seriesModel.getData();\n    var lineStyleModel = seriesModel.getModel('lineStyle');\n    var areaStyleModel = seriesModel.getModel('areaStyle');\n    var points = data.mapArray(data.getItemLayout);\n    var isCoordSysPolar = coordSys.type === 'polar';\n    var prevCoordSys = this._coordSys;\n    var symbolDraw = this._symbolDraw;\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var lineGroup = this._lineGroup;\n    var hasAnimation = seriesModel.get('animation');\n    var isAreaChart = !areaStyleModel.isEmpty();\n    var valueOrigin = areaStyleModel.get('origin');\n    var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);\n    var stackedOnPoints = getStackedOnPoints(coordSys, data, dataCoordInfo);\n    var showSymbol = seriesModel.get('showSymbol');\n    var isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data, coordSys); // Remove temporary symbols\n\n    var oldData = this._data;\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    }); // Remove previous created symbols if showSymbol changed to false\n\n    if (!showSymbol) {\n      symbolDraw.remove();\n    }\n\n    group.add(lineGroup); // FIXME step not support polar\n\n    var step = !isCoordSysPolar && seriesModel.get('step'); // Initialization animation or coordinate system changed\n\n    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isIgnoreFunc,\n        clipShape: createClipShape(coordSys, false, true, seriesModel)\n      });\n\n      if (step) {\n        // TODO If stacked series is not step\n        points = turnPointsIntoStep(points, coordSys, step);\n        stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n      }\n\n      polyline = this._newPolyline(points, coordSys, hasAnimation);\n\n      if (isAreaChart) {\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      }\n\n      lineGroup.setClipPath(createClipShape(coordSys, true, false, seriesModel));\n    } else {\n      if (isAreaChart && !polygon) {\n        // If areaStyle is added\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      } else if (polygon && !isAreaChart) {\n        // If areaStyle is removed\n        lineGroup.remove(polygon);\n        polygon = this._polygon = null;\n      } // Update clipPath\n\n\n      lineGroup.setClipPath(createClipShape(coordSys, false, false, seriesModel)); // Always update, or it is wrong in the case turning on legend\n      // because points are not changed\n\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isIgnoreFunc,\n        clipShape: createClipShape(coordSys, false, true, seriesModel)\n      }); // Stop symbol animation and sync with line points\n      // FIXME performance?\n\n      data.eachItemGraphicEl(function (el) {\n        el.stopAnimation(true);\n      }); // In the case data zoom triggerred refreshing frequently\n      // Data may not change if line has a category axis. So it should animate nothing\n\n      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {\n        if (hasAnimation) {\n          this._updateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin);\n        } else {\n          // Not do it in update with animation\n          if (step) {\n            // TODO If stacked series is not step\n            points = turnPointsIntoStep(points, coordSys, step);\n            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n          }\n\n          polyline.setShape({\n            points: points\n          });\n          polygon && polygon.setShape({\n            points: points,\n            stackedOnPoints: stackedOnPoints\n          });\n        }\n      }\n    }\n\n    var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n    polyline.useStyle(zrUtil.defaults( // Use color in lineStyle first\n    lineStyleModel.getLineStyle(), {\n      fill: 'none',\n      stroke: visualColor,\n      lineJoin: 'bevel'\n    }));\n    var smooth = seriesModel.get('smooth');\n    smooth = getSmooth(seriesModel.get('smooth'));\n    polyline.setShape({\n      smooth: smooth,\n      smoothMonotone: seriesModel.get('smoothMonotone'),\n      connectNulls: seriesModel.get('connectNulls')\n    });\n\n    if (polygon) {\n      var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');\n      var stackedOnSmooth = 0;\n      polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {\n        fill: visualColor,\n        opacity: 0.7,\n        lineJoin: 'bevel'\n      }));\n\n      if (stackedOnSeries) {\n        stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n      }\n\n      polygon.setShape({\n        smooth: smooth,\n        stackedOnSmooth: stackedOnSmooth,\n        smoothMonotone: seriesModel.get('smoothMonotone'),\n        connectNulls: seriesModel.get('connectNulls')\n      });\n    }\n\n    this._data = data; // Save the coordinate system for transition animation when data changed\n\n    this._coordSys = coordSys;\n    this._stackedOnPoints = stackedOnPoints;\n    this._points = points;\n    this._step = step;\n    this._valueOrigin = valueOrigin;\n  },\n  dispose: function () {},\n  highlight: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (!symbol) {\n        // Create a temporary symbol if it is not exists\n        var pt = data.getItemLayout(dataIndex);\n\n        if (!pt) {\n          // Null data\n          return;\n        }\n\n        symbol = new SymbolClz(data, dataIndex);\n        symbol.position = pt;\n        symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));\n        symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n        symbol.__temp = true;\n        data.setItemGraphicEl(dataIndex, symbol); // Stop scale animation\n\n        symbol.stopSymbolAnimation(true);\n        this.group.add(symbol);\n      }\n\n      symbol.highlight();\n    } else {\n      // Highlight whole series\n      ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n  downplay: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (symbol) {\n        if (symbol.__temp) {\n          data.setItemGraphicEl(dataIndex, null);\n          this.group.remove(symbol);\n        } else {\n          symbol.downplay();\n        }\n      }\n    } else {\n      // FIXME\n      // can not downplay completely.\n      // Downplay whole series\n      ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolyline: function (points) {\n    var polyline = this._polyline; // Remove previous created polyline\n\n    if (polyline) {\n      this._lineGroup.remove(polyline);\n    }\n\n    polyline = new Polyline({\n      shape: {\n        points: points\n      },\n      silent: true,\n      z2: 10\n    });\n\n    this._lineGroup.add(polyline);\n\n    this._polyline = polyline;\n    return polyline;\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} stackedOnPoints\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolygon: function (points, stackedOnPoints) {\n    var polygon = this._polygon; // Remove previous created polygon\n\n    if (polygon) {\n      this._lineGroup.remove(polygon);\n    }\n\n    polygon = new Polygon({\n      shape: {\n        points: points,\n        stackedOnPoints: stackedOnPoints\n      },\n      silent: true\n    });\n\n    this._lineGroup.add(polygon);\n\n    this._polygon = polygon;\n    return polygon;\n  },\n\n  /**\n   * @private\n   */\n  // FIXME Two value axis\n  _updateAnimation: function (data, stackedOnPoints, coordSys, api, step, valueOrigin) {\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var seriesModel = data.hostModel;\n    var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);\n    var current = diff.current;\n    var stackedOnCurrent = diff.stackedOnCurrent;\n    var next = diff.next;\n    var stackedOnNext = diff.stackedOnNext;\n\n    if (step) {\n      // TODO If stacked series is not step\n      current = turnPointsIntoStep(diff.current, coordSys, step);\n      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n      next = turnPointsIntoStep(diff.next, coordSys, step);\n      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n    } // `diff.current` is subset of `current` (which should be ensured by\n    // turnPointsIntoStep), so points in `__points` can be updated when\n    // points in `current` are update during animation.\n\n\n    polyline.shape.__points = diff.current;\n    polyline.shape.points = current;\n    graphic.updateProps(polyline, {\n      shape: {\n        points: next\n      }\n    }, seriesModel);\n\n    if (polygon) {\n      polygon.setShape({\n        points: current,\n        stackedOnPoints: stackedOnCurrent\n      });\n      graphic.updateProps(polygon, {\n        shape: {\n          points: next,\n          stackedOnPoints: stackedOnNext\n        }\n      }, seriesModel);\n    }\n\n    var updatedDataInfo = [];\n    var diffStatus = diff.status;\n\n    for (var i = 0; i < diffStatus.length; i++) {\n      var cmd = diffStatus[i].cmd;\n\n      if (cmd === '=') {\n        var el = data.getItemGraphicEl(diffStatus[i].idx1);\n\n        if (el) {\n          updatedDataInfo.push({\n            el: el,\n            ptIdx: i // Index of points\n\n          });\n        }\n      }\n    }\n\n    if (polyline.animators && polyline.animators.length) {\n      polyline.animators[0].during(function () {\n        for (var i = 0; i < updatedDataInfo.length; i++) {\n          var el = updatedDataInfo[i].el;\n          el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n        }\n      });\n    }\n  },\n  remove: function (ecModel) {\n    var group = this.group;\n    var oldData = this._data;\n\n    this._lineGroup.removeAll();\n\n    this._symbolDraw.remove(true); // Remove temporary created elements when highlighting\n\n\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    });\n    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_echarts@4.1.0@echarts/lib/chart/line/LineView.js\n// module id = +jdH\n// module chunks = 0","var graphic = require(\"../../util/graphic\");\n\nvar SymbolClz = require(\"./Symbol\");\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar isObject = _util.isObject;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n/**\n * @constructor\n * @alias module:echarts/chart/helper/SymbolDraw\n * @param {module:zrender/graphic/Group} [symbolCtor]\n */\nfunction SymbolDraw(symbolCtor) {\n  this.group = new graphic.Group();\n  this._symbolCtor = symbolCtor || SymbolClz;\n}\n\nvar symbolDrawProto = SymbolDraw.prototype;\n\nfunction symbolNeedsDraw(data, point, idx, opt) {\n  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) // We do not set clipShape on group, because it will cut part of\n  // the symbol element shape. We use the same clip shape here as\n  // the line clip.\n  && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';\n}\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.updateData = function (data, opt) {\n  opt = normalizeUpdateOpt(opt);\n  var group = this.group;\n  var seriesModel = data.hostModel;\n  var oldData = this._data;\n  var SymbolCtor = this._symbolCtor;\n  var seriesScope = makeSeriesScope(data); // There is no oldLineData only when first rendering or switching from\n  // stream mode to normal mode, where previous elements should be removed.\n\n  if (!oldData) {\n    group.removeAll();\n  }\n\n  data.diff(oldData).add(function (newIdx) {\n    var point = data.getItemLayout(newIdx);\n\n    if (symbolNeedsDraw(data, point, newIdx, opt)) {\n      var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n      symbolEl.attr('position', point);\n      data.setItemGraphicEl(newIdx, symbolEl);\n      group.add(symbolEl);\n    }\n  }).update(function (newIdx, oldIdx) {\n    var symbolEl = oldData.getItemGraphicEl(oldIdx);\n    var point = data.getItemLayout(newIdx);\n\n    if (!symbolNeedsDraw(data, point, newIdx, opt)) {\n      group.remove(symbolEl);\n      return;\n    }\n\n    if (!symbolEl) {\n      symbolEl = new SymbolCtor(data, newIdx);\n      symbolEl.attr('position', point);\n    } else {\n      symbolEl.updateData(data, newIdx, seriesScope);\n      graphic.updateProps(symbolEl, {\n        position: point\n      }, seriesModel);\n    } // Add back\n\n\n    group.add(symbolEl);\n    data.setItemGraphicEl(newIdx, symbolEl);\n  }).remove(function (oldIdx) {\n    var el = oldData.getItemGraphicEl(oldIdx);\n    el && el.fadeOut(function () {\n      group.remove(el);\n    });\n  }).execute();\n  this._data = data;\n};\n\nsymbolDrawProto.isPersistent = function () {\n  return true;\n};\n\nsymbolDrawProto.updateLayout = function () {\n  var data = this._data;\n\n  if (data) {\n    // Not use animation\n    data.eachItemGraphicEl(function (el, idx) {\n      var point = data.getItemLayout(idx);\n      el.attr('position', point);\n    });\n  }\n};\n\nsymbolDrawProto.incrementalPrepareUpdate = function (data) {\n  this._seriesScope = makeSeriesScope(data);\n  this._data = null;\n  this.group.removeAll();\n};\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.incrementalUpdate = function (taskParams, data, opt) {\n  opt = normalizeUpdateOpt(opt);\n\n  function updateIncrementalAndHover(el) {\n    if (!el.isGroup) {\n      el.incremental = el.useHoverLayer = true;\n    }\n  }\n\n  for (var idx = taskParams.start; idx < taskParams.end; idx++) {\n    var point = data.getItemLayout(idx);\n\n    if (symbolNeedsDraw(data, point, idx, opt)) {\n      var el = new this._symbolCtor(data, idx, this._seriesScope);\n      el.traverse(updateIncrementalAndHover);\n      el.attr('position', point);\n      this.group.add(el);\n      data.setItemGraphicEl(idx, el);\n    }\n  }\n};\n\nfunction normalizeUpdateOpt(opt) {\n  if (opt != null && !isObject(opt)) {\n    opt = {\n      isIgnore: opt\n    };\n  }\n\n  return opt || {};\n}\n\nsymbolDrawProto.remove = function (enableAnimation) {\n  var group = this.group;\n  var data = this._data; // Incremental model do not have this._data.\n\n  if (data && enableAnimation) {\n    data.eachItemGraphicEl(function (el) {\n      el.fadeOut(function () {\n        group.remove(el);\n      });\n    });\n  } else {\n    group.removeAll();\n  }\n};\n\nfunction makeSeriesScope(data) {\n  var seriesModel = data.hostModel;\n  return {\n    itemStyle: seriesModel.getModel('itemStyle').getItemStyle(['color']),\n    hoverItemStyle: seriesModel.getModel('emphasis.itemStyle').getItemStyle(),\n    symbolRotate: seriesModel.get('symbolRotate'),\n    symbolOffset: seriesModel.get('symbolOffset'),\n    hoverAnimation: seriesModel.get('hoverAnimation'),\n    labelModel: seriesModel.getModel('label'),\n    hoverLabelModel: seriesModel.getModel('emphasis.label'),\n    cursorStyle: seriesModel.get('cursor')\n  };\n}\n\nvar _default = SymbolDraw;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_echarts@4.1.0@echarts/lib/chart/helper/SymbolDraw.js\n// module id = 3LBH\n// module chunks = 0","/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar samplers = {\n  average: function (frame) {\n    var sum = 0;\n    var count = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      if (!isNaN(frame[i])) {\n        sum += frame[i];\n        count++;\n      }\n    } // Return NaN if count is 0\n\n\n    return count === 0 ? NaN : sum / count;\n  },\n  sum: function (frame) {\n    var sum = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      // Ignore NaN\n      sum += frame[i] || 0;\n    }\n\n    return sum;\n  },\n  max: function (frame) {\n    var max = -Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] > max && (max = frame[i]);\n    } // NaN will cause illegal axis extent.\n\n\n    return isFinite(max) ? max : NaN;\n  },\n  min: function (frame) {\n    var min = Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] < min && (min = frame[i]);\n    } // NaN will cause illegal axis extent.\n\n\n    return isFinite(min) ? min : NaN;\n  },\n  // TODO\n  // Median\n  nearest: function (frame) {\n    return frame[0];\n  }\n};\n\nvar indexSampler = function (frame, value) {\n  return Math.round(frame.length / 2);\n};\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    modifyOutputEnd: true,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var sampling = seriesModel.get('sampling');\n      var coordSys = seriesModel.coordinateSystem; // Only cartesian2d support down sampling\n\n      if (coordSys.type === 'cartesian2d' && sampling) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var extent = baseAxis.getExtent(); // Coordinste system has been resized\n\n        var size = extent[1] - extent[0];\n        var rate = Math.round(data.count() / size);\n\n        if (rate > 1) {\n          var sampler;\n\n          if (typeof sampling === 'string') {\n            sampler = samplers[sampling];\n          } else if (typeof sampling === 'function') {\n            sampler = sampling;\n          }\n\n          if (sampler) {\n            // Only support sample the first dim mapped from value axis.\n            seriesModel.setData(data.downSample(data.mapDimension(valueAxis.dim), 1 / rate, sampler, indexSampler));\n          }\n        }\n      }\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_echarts@4.1.0@echarts/lib/processor/dataSample.js\n// module id = 3t39\n// module chunks = 0","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Axis = require(\"../Axis\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction AngleAxis(scale, angleExtent) {\n  angleExtent = angleExtent || [0, 360];\n  Axis.call(this, 'angle', scale, angleExtent);\n  /**\n   * Axis type\n   *  - 'category'\n   *  - 'value'\n   *  - 'time'\n   *  - 'log'\n   * @type {string}\n   */\n\n  this.type = 'category';\n}\n\nAngleAxis.prototype = {\n  constructor: AngleAxis,\n\n  /**\n   * @override\n   */\n  pointToData: function (point, clamp) {\n    return this.polar.pointToData(point, clamp)[this.dim === 'radius' ? 0 : 1];\n  },\n  dataToAngle: Axis.prototype.dataToCoord,\n  angleToData: Axis.prototype.coordToData\n};\nzrUtil.inherits(AngleAxis, Axis);\nvar _default = AngleAxis;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_echarts@4.1.0@echarts/lib/coord/polar/AngleAxis.js\n// module id = 802A\n// module chunks = 0","var _helper = require(\"./helper\");\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// var arrayDiff = require('zrender/src/core/arrayDiff');\n// 'zrender/src/core/arrayDiff' has been used before, but it did\n// not do well in performance when roam with fixed dataZoom window.\n// function convertToIntId(newIdList, oldIdList) {\n//     // Generate int id instead of string id.\n//     // Compare string maybe slow in score function of arrDiff\n//     // Assume id in idList are all unique\n//     var idIndicesMap = {};\n//     var idx = 0;\n//     for (var i = 0; i < newIdList.length; i++) {\n//         idIndicesMap[newIdList[i]] = idx;\n//         newIdList[i] = idx++;\n//     }\n//     for (var i = 0; i < oldIdList.length; i++) {\n//         var oldId = oldIdList[i];\n//         // Same with newIdList\n//         if (idIndicesMap[oldId]) {\n//             oldIdList[i] = idIndicesMap[oldId];\n//         }\n//         else {\n//             oldIdList[i] = idx++;\n//         }\n//     }\n// }\nfunction diffData(oldData, newData) {\n  var diffResult = [];\n  newData.diff(oldData).add(function (idx) {\n    diffResult.push({\n      cmd: '+',\n      idx: idx\n    });\n  }).update(function (newIdx, oldIdx) {\n    diffResult.push({\n      cmd: '=',\n      idx: oldIdx,\n      idx1: newIdx\n    });\n  }).remove(function (idx) {\n    diffResult.push({\n      cmd: '-',\n      idx: idx\n    });\n  }).execute();\n  return diffResult;\n}\n\nfunction _default(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {\n  var diff = diffData(oldData, newData); // var newIdList = newData.mapArray(newData.getId);\n  // var oldIdList = oldData.mapArray(oldData.getId);\n  // convertToIntId(newIdList, oldIdList);\n  // // FIXME One data ?\n  // diff = arrayDiff(oldIdList, newIdList);\n\n  var currPoints = [];\n  var nextPoints = []; // Points for stacking base line\n\n  var currStackedPoints = [];\n  var nextStackedPoints = [];\n  var status = [];\n  var sortedIndices = [];\n  var rawIndices = [];\n  var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);\n  var oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);\n\n  for (var i = 0; i < diff.length; i++) {\n    var diffItem = diff[i];\n    var pointAdded = true; // FIXME, animation is not so perfect when dataZoom window moves fast\n    // Which is in case remvoing or add more than one data in the tail or head\n\n    switch (diffItem.cmd) {\n      case '=':\n        var currentPt = oldData.getItemLayout(diffItem.idx);\n        var nextPt = newData.getItemLayout(diffItem.idx1); // If previous data is NaN, use next point directly\n\n        if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n          currentPt = nextPt.slice();\n        }\n\n        currPoints.push(currentPt);\n        nextPoints.push(nextPt);\n        currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n        nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n        rawIndices.push(newData.getRawIndex(diffItem.idx1));\n        break;\n\n      case '+':\n        var idx = diffItem.idx;\n        currPoints.push(oldCoordSys.dataToPoint([newData.get(newDataOldCoordInfo.dataDimsForPoint[0], idx), newData.get(newDataOldCoordInfo.dataDimsForPoint[1], idx)]));\n        nextPoints.push(newData.getItemLayout(idx).slice());\n        currStackedPoints.push(getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, idx));\n        nextStackedPoints.push(newStackedOnPoints[idx]);\n        rawIndices.push(newData.getRawIndex(idx));\n        break;\n\n      case '-':\n        var idx = diffItem.idx;\n        var rawIndex = oldData.getRawIndex(idx); // Data is replaced. In the case of dynamic data queue\n        // FIXME FIXME FIXME\n\n        if (rawIndex !== idx) {\n          currPoints.push(oldData.getItemLayout(idx));\n          nextPoints.push(newCoordSys.dataToPoint([oldData.get(oldDataNewCoordInfo.dataDimsForPoint[0], idx), oldData.get(oldDataNewCoordInfo.dataDimsForPoint[1], idx)]));\n          currStackedPoints.push(oldStackedOnPoints[idx]);\n          nextStackedPoints.push(getStackedOnPoint(oldDataNewCoordInfo, newCoordSys, oldData, idx));\n          rawIndices.push(rawIndex);\n        } else {\n          pointAdded = false;\n        }\n\n    } // Original indices\n\n\n    if (pointAdded) {\n      status.push(diffItem);\n      sortedIndices.push(sortedIndices.length);\n    }\n  } // Diff result may be crossed if all items are changed\n  // Sort by data index\n\n\n  sortedIndices.sort(function (a, b) {\n    return rawIndices[a] - rawIndices[b];\n  });\n  var sortedCurrPoints = [];\n  var sortedNextPoints = [];\n  var sortedCurrStackedPoints = [];\n  var sortedNextStackedPoints = [];\n  var sortedStatus = [];\n\n  for (var i = 0; i < sortedIndices.length; i++) {\n    var idx = sortedIndices[i];\n    sortedCurrPoints[i] = currPoints[idx];\n    sortedNextPoints[i] = nextPoints[idx];\n    sortedCurrStackedPoints[i] = currStackedPoints[idx];\n    sortedNextStackedPoints[i] = nextStackedPoints[idx];\n    sortedStatus[i] = status[idx];\n  }\n\n  return {\n    current: sortedCurrPoints,\n    next: sortedNextPoints,\n    stackedOnCurrent: sortedCurrStackedPoints,\n    stackedOnNext: sortedNextStackedPoints,\n    status: sortedStatus\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_echarts@4.1.0@echarts/lib/chart/line/lineAnimationDiff.js\n// module id = BrYk\n// module chunks = 0","var Path = require(\"zrender/lib/graphic/Path\");\n\nvar vec2 = require(\"zrender/lib/core/vector\");\n\nvar fixClipWithShadow = require(\"zrender/lib/graphic/helper/fixClipWithShadow\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Poly path support NaN point\nvar vec2Min = vec2.min;\nvar vec2Max = vec2.max;\nvar scaleAndAdd = vec2.scaleAndAdd;\nvar v2Copy = vec2.copy; // Temporary variable\n\nvar v = [];\nvar cp0 = [];\nvar cp1 = [];\n\nfunction isPointNull(p) {\n  return isNaN(p[0]) || isNaN(p[1]);\n}\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  // if (smoothMonotone == null) {\n  //     if (isMono(points, 'x')) {\n  //         return drawMono(ctx, points, start, segLen, allLen,\n  //             dir, smoothMin, smoothMax, smooth, 'x', connectNulls);\n  //     }\n  //     else if (isMono(points, 'y')) {\n  //         return drawMono(ctx, points, start, segLen, allLen,\n  //             dir, smoothMin, smoothMax, smooth, 'y', connectNulls);\n  //     }\n  //     else {\n  //         return drawNonMono.apply(this, arguments);\n  //     }\n  // }\n  // else if (smoothMonotone !== 'none' && isMono(points, smoothMonotone)) {\n  //     return drawMono.apply(this, arguments);\n  // }\n  // else {\n  //     return drawNonMono.apply(this, arguments);\n  // }\n  if (smoothMonotone === 'none' || !smoothMonotone) {\n    return drawNonMono.apply(this, arguments);\n  } else {\n    return drawMono.apply(this, arguments);\n  }\n}\n/**\n * Check if points is in monotone.\n *\n * @param {number[][]} points         Array of points which is in [x, y] form\n * @param {string}     smoothMonotone 'x', 'y', or 'none', stating for which\n *                                    dimension that is checking.\n *                                    If is 'none', `drawNonMono` should be\n *                                    called.\n *                                    If is undefined, either being monotone\n *                                    in 'x' or 'y' will call `drawMono`.\n */\n// function isMono(points, smoothMonotone) {\n//     if (points.length <= 1) {\n//         return true;\n//     }\n//     var dim = smoothMonotone === 'x' ? 0 : 1;\n//     var last = points[0][dim];\n//     var lastDiff = 0;\n//     for (var i = 1; i < points.length; ++i) {\n//         var diff = points[i][dim] - last;\n//         if (!isNaN(diff) && !isNaN(lastDiff)\n//             && diff !== 0 && lastDiff !== 0\n//             && ((diff >= 0) !== (lastDiff >= 0))\n//         ) {\n//             return false;\n//         }\n//         if (!isNaN(diff) && diff !== 0) {\n//             lastDiff = diff;\n//             last = points[i][dim];\n//         }\n//     }\n//     return true;\n// }\n\n/**\n * Draw smoothed line in monotone, in which only vertical or horizontal bezier\n * control points will be used. This should be used when points are monotone\n * either in x or y dimension.\n */\n\n\nfunction drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n    } else {\n      if (smooth > 0) {\n        var prevP = points[prevIdx];\n        var dim = smoothMonotone === 'y' ? 1 : 0; // Length of control point to p, either in x or y, but not both\n\n        var ctrlLen = (p[dim] - prevP[dim]) * smooth;\n        v2Copy(cp0, prevP);\n        cp0[dim] = prevP[dim] + ctrlLen;\n        v2Copy(cp1, p);\n        cp1[dim] = p[dim] - ctrlLen;\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n/**\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\n * situations. This should be used when points are non-monotone neither in x or\n * y dimension.\n */\n\n\nfunction drawNonMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n      v2Copy(cp0, p);\n    } else {\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextP = points[nextIdx];\n\n        if (connectNulls) {\n          // Find next point not null\n          while (nextP && isPointNull(points[nextIdx])) {\n            nextIdx += dir;\n            nextP = points[nextIdx];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var prevP = points[prevIdx];\n        var nextP = points[nextIdx]; // Last point\n\n        if (!nextP || isPointNull(nextP)) {\n          v2Copy(cp1, p);\n        } else {\n          // If next data is null in not connect case\n          if (isPointNull(nextP) && !connectNulls) {\n            nextP = p;\n          }\n\n          vec2.sub(v, nextP, prevP);\n          var lenPrevSeg;\n          var lenNextSeg;\n\n          if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n            var dim = smoothMonotone === 'x' ? 0 : 1;\n            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n          } else {\n            lenPrevSeg = vec2.dist(p, prevP);\n            lenNextSeg = vec2.dist(p, nextP);\n          } // Use ratio of seg length\n\n\n          ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n          scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n        } // Smooth constraint\n\n\n        vec2Min(cp0, cp0, smoothMax);\n        vec2Max(cp0, cp0, smoothMin);\n        vec2Min(cp1, cp1, smoothMax);\n        vec2Max(cp1, cp1, smoothMin);\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment\n\n        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n\nfunction getBoundingBox(points, smoothConstraint) {\n  var ptMin = [Infinity, Infinity];\n  var ptMax = [-Infinity, -Infinity];\n\n  if (smoothConstraint) {\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n\n      if (pt[0] < ptMin[0]) {\n        ptMin[0] = pt[0];\n      }\n\n      if (pt[1] < ptMin[1]) {\n        ptMin[1] = pt[1];\n      }\n\n      if (pt[0] > ptMax[0]) {\n        ptMax[0] = pt[0];\n      }\n\n      if (pt[1] > ptMax[1]) {\n        ptMax[1] = pt[1];\n      }\n    }\n  }\n\n  return {\n    min: smoothConstraint ? ptMin : ptMax,\n    max: smoothConstraint ? ptMax : ptMin\n  };\n}\n\nvar Polyline = Path.extend({\n  type: 'ec-polyline',\n  shape: {\n    points: [],\n    smooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  style: {\n    fill: null,\n    stroke: '#000'\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length;\n    var result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  }\n});\nvar Polygon = Path.extend({\n  type: 'ec-polygon',\n  shape: {\n    points: [],\n    // Offset between stacked base points and points\n    stackedOnPoints: [],\n    smooth: 0,\n    stackedOnSmooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length;\n    var smoothMonotone = shape.smoothMonotone;\n    var bbox = getBoundingBox(points, shape.smoothConstraint);\n    var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  }\n});\nexports.Polyline = Polyline;\nexports.Polygon = Polygon;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_echarts@4.1.0@echarts/lib/chart/line/poly.js\n// module id = Er0q\n// module chunks = 0","var echarts = require(\"../../echarts\");\n\nrequire(\"./AxisModel\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _default = echarts.extendComponentModel({\n  type: 'polar',\n  dependencies: ['polarAxis', 'angleAxis'],\n\n  /**\n   * @type {module:echarts/coord/polar/Polar}\n   */\n  coordinateSystem: null,\n\n  /**\n   * @param {string} axisType\n   * @return {module:echarts/coord/polar/AxisModel}\n   */\n  findAxisModel: function (axisType) {\n    var foundAxisModel;\n    var ecModel = this.ecModel;\n    ecModel.eachComponent(axisType, function (axisModel) {\n      if (axisModel.getCoordSysModel() === this) {\n        foundAxisModel = axisModel;\n      }\n    }, this);\n    return foundAxisModel;\n  },\n  defaultOption: {\n    zlevel: 0,\n    z: 0,\n    center: ['50%', '50%'],\n    radius: '80%'\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_echarts@4.1.0@echarts/lib/coord/polar/PolarModel.js\n// module id = FsJA\n// module chunks = 0","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar Model = require(\"../../model/Model\");\n\nvar AxisView = require(\"./AxisView\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar elementList = ['axisLine', 'axisLabel', 'axisTick', 'splitLine', 'splitArea'];\n\nfunction getAxisLineShape(polar, rExtent, angle) {\n  rExtent[1] > rExtent[0] && (rExtent = rExtent.slice().reverse());\n  var start = polar.coordToPoint([rExtent[0], angle]);\n  var end = polar.coordToPoint([rExtent[1], angle]);\n  return {\n    x1: start[0],\n    y1: start[1],\n    x2: end[0],\n    y2: end[1]\n  };\n}\n\nfunction getRadiusIdx(polar) {\n  var radiusAxis = polar.getRadiusAxis();\n  return radiusAxis.inverse ? 0 : 1;\n} // Remove the last tick which will overlap the first tick\n\n\nfunction fixAngleOverlap(list) {\n  var firstItem = list[0];\n  var lastItem = list[list.length - 1];\n\n  if (firstItem && lastItem && Math.abs(Math.abs(firstItem.coord - lastItem.coord) - 360) < 1e-4) {\n    list.pop();\n  }\n}\n\nvar _default = AxisView.extend({\n  type: 'angleAxis',\n  axisPointerClass: 'PolarAxisPointer',\n  render: function (angleAxisModel, ecModel) {\n    this.group.removeAll();\n\n    if (!angleAxisModel.get('show')) {\n      return;\n    }\n\n    var angleAxis = angleAxisModel.axis;\n    var polar = angleAxis.polar;\n    var radiusExtent = polar.getRadiusAxis().getExtent();\n    var ticksAngles = angleAxis.getTicksCoords();\n    var labels = zrUtil.map(angleAxis.getViewLabels(), function (labelItem) {\n      var labelItem = zrUtil.clone(labelItem);\n      labelItem.coord = angleAxis.dataToCoord(labelItem.tickValue);\n      return labelItem;\n    });\n    fixAngleOverlap(labels);\n    fixAngleOverlap(ticksAngles);\n    zrUtil.each(elementList, function (name) {\n      if (angleAxisModel.get(name + '.show') && (!angleAxis.scale.isBlank() || name === 'axisLine')) {\n        this['_' + name](angleAxisModel, polar, ticksAngles, radiusExtent, labels);\n      }\n    }, this);\n  },\n\n  /**\n   * @private\n   */\n  _axisLine: function (angleAxisModel, polar, ticksAngles, radiusExtent) {\n    var lineStyleModel = angleAxisModel.getModel('axisLine.lineStyle');\n    var circle = new graphic.Circle({\n      shape: {\n        cx: polar.cx,\n        cy: polar.cy,\n        r: radiusExtent[getRadiusIdx(polar)]\n      },\n      style: lineStyleModel.getLineStyle(),\n      z2: 1,\n      silent: true\n    });\n    circle.style.fill = null;\n    this.group.add(circle);\n  },\n\n  /**\n   * @private\n   */\n  _axisTick: function (angleAxisModel, polar, ticksAngles, radiusExtent) {\n    var tickModel = angleAxisModel.getModel('axisTick');\n    var tickLen = (tickModel.get('inside') ? -1 : 1) * tickModel.get('length');\n    var radius = radiusExtent[getRadiusIdx(polar)];\n    var lines = zrUtil.map(ticksAngles, function (tickAngleItem) {\n      return new graphic.Line({\n        shape: getAxisLineShape(polar, [radius, radius + tickLen], tickAngleItem.coord)\n      });\n    });\n    this.group.add(graphic.mergePath(lines, {\n      style: zrUtil.defaults(tickModel.getModel('lineStyle').getLineStyle(), {\n        stroke: angleAxisModel.get('axisLine.lineStyle.color')\n      })\n    }));\n  },\n\n  /**\n   * @private\n   */\n  _axisLabel: function (angleAxisModel, polar, ticksAngles, radiusExtent, labels) {\n    var rawCategoryData = angleAxisModel.getCategories(true);\n    var commonLabelModel = angleAxisModel.getModel('axisLabel');\n    var labelMargin = commonLabelModel.get('margin'); // Use length of ticksAngles because it may remove the last tick to avoid overlapping\n\n    zrUtil.each(labels, function (labelItem, idx) {\n      var labelModel = commonLabelModel;\n      var tickValue = labelItem.tickValue;\n      var r = radiusExtent[getRadiusIdx(polar)];\n      var p = polar.coordToPoint([r + labelMargin, labelItem.coord]);\n      var cx = polar.cx;\n      var cy = polar.cy;\n      var labelTextAlign = Math.abs(p[0] - cx) / r < 0.3 ? 'center' : p[0] > cx ? 'left' : 'right';\n      var labelTextVerticalAlign = Math.abs(p[1] - cy) / r < 0.3 ? 'middle' : p[1] > cy ? 'top' : 'bottom';\n\n      if (rawCategoryData && rawCategoryData[tickValue] && rawCategoryData[tickValue].textStyle) {\n        labelModel = new Model(rawCategoryData[tickValue].textStyle, commonLabelModel, commonLabelModel.ecModel);\n      }\n\n      var textEl = new graphic.Text({\n        silent: true\n      });\n      this.group.add(textEl);\n      graphic.setTextStyle(textEl.style, labelModel, {\n        x: p[0],\n        y: p[1],\n        textFill: labelModel.getTextColor() || angleAxisModel.get('axisLine.lineStyle.color'),\n        text: labelItem.formattedLabel,\n        textAlign: labelTextAlign,\n        textVerticalAlign: labelTextVerticalAlign\n      });\n    }, this);\n  },\n\n  /**\n   * @private\n   */\n  _splitLine: function (angleAxisModel, polar, ticksAngles, radiusExtent) {\n    var splitLineModel = angleAxisModel.getModel('splitLine');\n    var lineStyleModel = splitLineModel.getModel('lineStyle');\n    var lineColors = lineStyleModel.get('color');\n    var lineCount = 0;\n    lineColors = lineColors instanceof Array ? lineColors : [lineColors];\n    var splitLines = [];\n\n    for (var i = 0; i < ticksAngles.length; i++) {\n      var colorIndex = lineCount++ % lineColors.length;\n      splitLines[colorIndex] = splitLines[colorIndex] || [];\n      splitLines[colorIndex].push(new graphic.Line({\n        shape: getAxisLineShape(polar, radiusExtent, ticksAngles[i].coord)\n      }));\n    } // Simple optimization\n    // Batching the lines if color are the same\n\n\n    for (var i = 0; i < splitLines.length; i++) {\n      this.group.add(graphic.mergePath(splitLines[i], {\n        style: zrUtil.defaults({\n          stroke: lineColors[i % lineColors.length]\n        }, lineStyleModel.getLineStyle()),\n        silent: true,\n        z: angleAxisModel.get('z')\n      }));\n    }\n  },\n\n  /**\n   * @private\n   */\n  _splitArea: function (angleAxisModel, polar, ticksAngles, radiusExtent) {\n    if (!ticksAngles.length) {\n      return;\n    }\n\n    var splitAreaModel = angleAxisModel.getModel('splitArea');\n    var areaStyleModel = splitAreaModel.getModel('areaStyle');\n    var areaColors = areaStyleModel.get('color');\n    var lineCount = 0;\n    areaColors = areaColors instanceof Array ? areaColors : [areaColors];\n    var splitAreas = [];\n    var RADIAN = Math.PI / 180;\n    var prevAngle = -ticksAngles[0].coord * RADIAN;\n    var r0 = Math.min(radiusExtent[0], radiusExtent[1]);\n    var r1 = Math.max(radiusExtent[0], radiusExtent[1]);\n    var clockwise = angleAxisModel.get('clockwise');\n\n    for (var i = 1; i < ticksAngles.length; i++) {\n      var colorIndex = lineCount++ % areaColors.length;\n      splitAreas[colorIndex] = splitAreas[colorIndex] || [];\n      splitAreas[colorIndex].push(new graphic.Sector({\n        shape: {\n          cx: polar.cx,\n          cy: polar.cy,\n          r0: r0,\n          r: r1,\n          startAngle: prevAngle,\n          endAngle: -ticksAngles[i].coord * RADIAN,\n          clockwise: clockwise\n        },\n        silent: true\n      }));\n      prevAngle = -ticksAngles[i].coord * RADIAN;\n    } // Simple optimization\n    // Batching the lines if color are the same\n\n\n    for (var i = 0; i < splitAreas.length; i++) {\n      this.group.add(graphic.mergePath(splitAreas[i], {\n        style: zrUtil.defaults({\n          fill: areaColors[i % areaColors.length]\n        }, areaStyleModel.getAreaStyle()),\n        silent: true\n      }));\n    }\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_echarts@4.1.0@echarts/lib/component/axis/AngleAxisView.js\n// module id = Mp8l\n// module chunks = 0","var _dataStackHelper = require(\"../../data/helper/dataStackHelper\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar map = _util.map;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @param {Object} coordSys\n * @param {module:echarts/data/List} data\n * @param {string} valueOrigin lineSeries.option.areaStyle.origin\n */\nfunction prepareDataCoordInfo(coordSys, data, valueOrigin) {\n  var baseAxis = coordSys.getBaseAxis();\n  var valueAxis = coordSys.getOtherAxis(baseAxis);\n  var valueStart = getValueStart(valueAxis, valueOrigin);\n  var baseAxisDim = baseAxis.dim;\n  var valueAxisDim = valueAxis.dim;\n  var valueDim = data.mapDimension(valueAxisDim);\n  var baseDim = data.mapDimension(baseAxisDim);\n  var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;\n  var dims = map(coordSys.dimensions, function (coordDim) {\n    return data.mapDimension(coordDim);\n  });\n  var stacked;\n  var stackResultDim = data.getCalculationInfo('stackResultDimension');\n\n  if (stacked |= isDimensionStacked(data, dims[0]\n  /*, dims[1]*/\n  )) {\n    // jshint ignore:line\n    dims[0] = stackResultDim;\n  }\n\n  if (stacked |= isDimensionStacked(data, dims[1]\n  /*, dims[0]*/\n  )) {\n    // jshint ignore:line\n    dims[1] = stackResultDim;\n  }\n\n  return {\n    dataDimsForPoint: dims,\n    valueStart: valueStart,\n    valueAxisDim: valueAxisDim,\n    baseAxisDim: baseAxisDim,\n    stacked: !!stacked,\n    valueDim: valueDim,\n    baseDim: baseDim,\n    baseDataOffset: baseDataOffset,\n    stackedOverDimension: data.getCalculationInfo('stackedOverDimension')\n  };\n}\n\nfunction getValueStart(valueAxis, valueOrigin) {\n  var valueStart = 0;\n  var extent = valueAxis.scale.getExtent();\n\n  if (valueOrigin === 'start') {\n    valueStart = extent[0];\n  } else if (valueOrigin === 'end') {\n    valueStart = extent[1];\n  } // auto\n  else {\n      // Both positive\n      if (extent[0] > 0) {\n        valueStart = extent[0];\n      } // Both negative\n      else if (extent[1] < 0) {\n          valueStart = extent[1];\n        } // If is one positive, and one negative, onZero shall be true\n\n    }\n\n  return valueStart;\n}\n\nfunction getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {\n  var value = NaN;\n\n  if (dataCoordInfo.stacked) {\n    value = data.get(data.getCalculationInfo('stackedOverDimension'), idx);\n  }\n\n  if (isNaN(value)) {\n    value = dataCoordInfo.valueStart;\n  }\n\n  var baseDataOffset = dataCoordInfo.baseDataOffset;\n  var stackedData = [];\n  stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);\n  stackedData[1 - baseDataOffset] = value;\n  return coordSys.dataToPoint(stackedData);\n}\n\nexports.prepareDataCoordInfo = prepareDataCoordInfo;\nexports.getStackedOnPoint = getStackedOnPoint;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_echarts@4.1.0@echarts/lib/chart/line/helper.js\n// module id = NHLq\n// module chunks = 0","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar ComponentModel = require(\"../../model/Component\");\n\nvar axisModelCreator = require(\"../axisModelCreator\");\n\nvar axisModelCommonMixin = require(\"../axisModelCommonMixin\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar PolarAxisModel = ComponentModel.extend({\n  type: 'polarAxis',\n\n  /**\n   * @type {module:echarts/coord/polar/AngleAxis|module:echarts/coord/polar/RadiusAxis}\n   */\n  axis: null,\n\n  /**\n   * @override\n   */\n  getCoordSysModel: function () {\n    return this.ecModel.queryComponents({\n      mainType: 'polar',\n      index: this.option.polarIndex,\n      id: this.option.polarId\n    })[0];\n  }\n});\nzrUtil.merge(PolarAxisModel.prototype, axisModelCommonMixin);\nvar polarAxisDefaultExtendedOption = {\n  angle: {\n    // polarIndex: 0,\n    // polarId: '',\n    startAngle: 90,\n    clockwise: true,\n    splitNumber: 12,\n    axisLabel: {\n      rotate: false\n    }\n  },\n  radius: {\n    // polarIndex: 0,\n    // polarId: '',\n    splitNumber: 5\n  }\n};\n\nfunction getAxisType(axisDim, option) {\n  // Default axis with data is category axis\n  return option.type || (option.data ? 'category' : 'value');\n}\n\naxisModelCreator('angle', PolarAxisModel, getAxisType, polarAxisDefaultExtendedOption.angle);\naxisModelCreator('radius', PolarAxisModel, getAxisType, polarAxisDefaultExtendedOption.radius);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_echarts@4.1.0@echarts/lib/coord/polar/AxisModel.js\n// module id = P9df\n// module chunks = 0","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar barPolar = require(\"../layout/barPolar\");\n\nrequire(\"../coord/polar/polarCreator\");\n\nrequire(\"./angleAxis\");\n\nrequire(\"./radiusAxis\");\n\nrequire(\"./axisPointer\");\n\nrequire(\"./axisPointer/PolarAxisPointer\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// For reducing size of echarts.min, barLayoutPolar is required by polar.\necharts.registerLayout(zrUtil.curry(barPolar, 'bar')); // Polar view\n\necharts.extendComponentView({\n  type: 'polar'\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_echarts@4.1.0@echarts/lib/component/polar.js\n// module id = PEyf\n// module chunks = 0","require(\"../coord/polar/polarCreator\");\n\nrequire(\"./axis/AngleAxisView\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_echarts@4.1.0@echarts/lib/component/angleAxis.js\n// module id = Pq3W\n// module chunks = 0","var _util = require(\"zrender/lib/core/util\");\n\nvar map = _util.map;\n\nvar createRenderPlanner = require(\"../chart/helper/createRenderPlanner\");\n\nvar _dataStackHelper = require(\"../data/helper/dataStackHelper\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    plan: createRenderPlanner(),\n    reset: function (seriesModel) {\n      var data = seriesModel.getData();\n      var coordSys = seriesModel.coordinateSystem;\n      var pipelineContext = seriesModel.pipelineContext;\n      var isLargeRender = pipelineContext.large;\n\n      if (!coordSys) {\n        return;\n      }\n\n      var dims = map(coordSys.dimensions, function (dim) {\n        return data.mapDimension(dim);\n      }).slice(0, 2);\n      var dimLen = dims.length;\n      var stackResultDim = data.getCalculationInfo('stackResultDimension');\n\n      if (isDimensionStacked(data, dims[0]\n      /*, dims[1]*/\n      )) {\n        dims[0] = stackResultDim;\n      }\n\n      if (isDimensionStacked(data, dims[1]\n      /*, dims[0]*/\n      )) {\n        dims[1] = stackResultDim;\n      }\n\n      function progress(params, data) {\n        var segCount = params.end - params.start;\n        var points = isLargeRender && new Float32Array(segCount * dimLen);\n\n        for (var i = params.start, offset = 0, tmpIn = [], tmpOut = []; i < params.end; i++) {\n          var point;\n\n          if (dimLen === 1) {\n            var x = data.get(dims[0], i);\n            point = !isNaN(x) && coordSys.dataToPoint(x, null, tmpOut);\n          } else {\n            var x = tmpIn[0] = data.get(dims[0], i);\n            var y = tmpIn[1] = data.get(dims[1], i); // Also {Array.<number>}, not undefined to avoid if...else... statement\n\n            point = !isNaN(x) && !isNaN(y) && coordSys.dataToPoint(tmpIn, null, tmpOut);\n          }\n\n          if (isLargeRender) {\n            points[offset++] = point ? point[0] : NaN;\n            points[offset++] = point ? point[1] : NaN;\n          } else {\n            data.setItemLayout(i, point && point.slice() || [NaN, NaN]);\n          }\n        }\n\n        isLargeRender && data.setLayout('symbolPoints', points);\n      }\n\n      return dimLen && {\n        progress: progress\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_echarts@4.1.0@echarts/lib/layout/points.js\n// module id = VErb\n// module chunks = 0","var echarts = require(\"../echarts\");\n\nrequire(\"./line/LineSeries\");\n\nrequire(\"./line/LineView\");\n\nvar visualSymbol = require(\"../visual/symbol\");\n\nvar layoutPoints = require(\"../layout/points\");\n\nvar dataSample = require(\"../processor/dataSample\");\n\nrequire(\"../component/gridSimple\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// In case developer forget to include grid component\necharts.registerVisual(visualSymbol('line', 'circle', 'line'));\necharts.registerLayout(layoutPoints('line')); // Down sample after filter\n\necharts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, dataSample('line'));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_echarts@4.1.0@echarts/lib/chart/line.js\n// module id = aO2o\n// module chunks = 0","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar _symbol = require(\"../../util/symbol\");\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = require(\"../../util/graphic\");\n\nvar _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\n\nvar _labelHelper = require(\"./labelHelper\");\n\nvar getDefaultLabel = _labelHelper.getDefaultLabel;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @module echarts/chart/helper/Symbol\n */\n\n/**\n * @constructor\n * @alias {module:echarts/chart/helper/Symbol}\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @extends {module:zrender/graphic/Group}\n */\nfunction SymbolClz(data, idx, seriesScope) {\n  graphic.Group.call(this);\n  this.updateData(data, idx, seriesScope);\n}\n\nvar symbolProto = SymbolClz.prototype;\n/**\n * @public\n * @static\n * @param {module:echarts/data/List} data\n * @param {number} dataIndex\n * @return {Array.<number>} [width, height]\n */\n\nvar getSymbolSize = SymbolClz.getSymbolSize = function (data, idx) {\n  var symbolSize = data.getItemVisual(idx, 'symbolSize');\n  return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];\n};\n\nfunction getScale(symbolSize) {\n  return [symbolSize[0] / 2, symbolSize[1] / 2];\n}\n\nfunction driftSymbol(dx, dy) {\n  this.parent.drift(dx, dy);\n}\n\nsymbolProto._createSymbol = function (symbolType, data, idx, symbolSize, keepAspect) {\n  // Remove paths created before\n  this.removeAll();\n  var color = data.getItemVisual(idx, 'color'); // var symbolPath = createSymbol(\n  //     symbolType, -0.5, -0.5, 1, 1, color\n  // );\n  // If width/height are set too small (e.g., set to 1) on ios10\n  // and macOS Sierra, a circle stroke become a rect, no matter what\n  // the scale is set. So we set width/height as 2. See #4150.\n\n  var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, color, keepAspect);\n  symbolPath.attr({\n    z2: 100,\n    culling: true,\n    scale: getScale(symbolSize)\n  }); // Rewrite drift method\n\n  symbolPath.drift = driftSymbol;\n  this._symbolType = symbolType;\n  this.add(symbolPath);\n};\n/**\n * Stop animation\n * @param {boolean} toLastFrame\n */\n\n\nsymbolProto.stopSymbolAnimation = function (toLastFrame) {\n  this.childAt(0).stopAnimation(toLastFrame);\n};\n/**\n * FIXME:\n * Caution: This method breaks the encapsulation of this module,\n * but it indeed brings convenience. So do not use the method\n * unless you detailedly know all the implements of `Symbol`,\n * especially animation.\n *\n * Get symbol path element.\n */\n\n\nsymbolProto.getSymbolPath = function () {\n  return this.childAt(0);\n};\n/**\n * Get scale(aka, current symbol size).\n * Including the change caused by animation\n */\n\n\nsymbolProto.getScale = function () {\n  return this.childAt(0).scale;\n};\n/**\n * Highlight symbol\n */\n\n\nsymbolProto.highlight = function () {\n  this.childAt(0).trigger('emphasis');\n};\n/**\n * Downplay symbol\n */\n\n\nsymbolProto.downplay = function () {\n  this.childAt(0).trigger('normal');\n};\n/**\n * @param {number} zlevel\n * @param {number} z\n */\n\n\nsymbolProto.setZ = function (zlevel, z) {\n  var symbolPath = this.childAt(0);\n  symbolPath.zlevel = zlevel;\n  symbolPath.z = z;\n};\n\nsymbolProto.setDraggable = function (draggable) {\n  var symbolPath = this.childAt(0);\n  symbolPath.draggable = draggable;\n  symbolPath.cursor = draggable ? 'move' : 'pointer';\n};\n/**\n * Update symbol properties\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Object} [seriesScope]\n * @param {Object} [seriesScope.itemStyle]\n * @param {Object} [seriesScope.hoverItemStyle]\n * @param {Object} [seriesScope.symbolRotate]\n * @param {Object} [seriesScope.symbolOffset]\n * @param {module:echarts/model/Model} [seriesScope.labelModel]\n * @param {module:echarts/model/Model} [seriesScope.hoverLabelModel]\n * @param {boolean} [seriesScope.hoverAnimation]\n * @param {Object} [seriesScope.cursorStyle]\n * @param {module:echarts/model/Model} [seriesScope.itemModel]\n * @param {string} [seriesScope.symbolInnerColor]\n * @param {Object} [seriesScope.fadeIn=false]\n */\n\n\nsymbolProto.updateData = function (data, idx, seriesScope) {\n  this.silent = false;\n  var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n  var seriesModel = data.hostModel;\n  var symbolSize = getSymbolSize(data, idx);\n  var isInit = symbolType !== this._symbolType;\n\n  if (isInit) {\n    var keepAspect = data.getItemVisual(idx, 'symbolKeepAspect');\n\n    this._createSymbol(symbolType, data, idx, symbolSize, keepAspect);\n  } else {\n    var symbolPath = this.childAt(0);\n    symbolPath.silent = false;\n    graphic.updateProps(symbolPath, {\n      scale: getScale(symbolSize)\n    }, seriesModel, idx);\n  }\n\n  this._updateCommon(data, idx, symbolSize, seriesScope);\n\n  if (isInit) {\n    var symbolPath = this.childAt(0);\n    var fadeIn = seriesScope && seriesScope.fadeIn;\n    var target = {\n      scale: symbolPath.scale.slice()\n    };\n    fadeIn && (target.style = {\n      opacity: symbolPath.style.opacity\n    });\n    symbolPath.scale = [0, 0];\n    fadeIn && (symbolPath.style.opacity = 0);\n    graphic.initProps(symbolPath, target, seriesModel, idx);\n  }\n\n  this._seriesModel = seriesModel;\n}; // Update common properties\n\n\nvar normalStyleAccessPath = ['itemStyle'];\nvar emphasisStyleAccessPath = ['emphasis', 'itemStyle'];\nvar normalLabelAccessPath = ['label'];\nvar emphasisLabelAccessPath = ['emphasis', 'label'];\n/**\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Array.<number>} symbolSize\n * @param {Object} [seriesScope]\n */\n\nsymbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n  var symbolPath = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var color = data.getItemVisual(idx, 'color'); // Reset style\n\n  if (symbolPath.type !== 'image') {\n    symbolPath.useStyle({\n      strokeNoScale: true\n    });\n  }\n\n  var itemStyle = seriesScope && seriesScope.itemStyle;\n  var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n  var symbolRotate = seriesScope && seriesScope.symbolRotate;\n  var symbolOffset = seriesScope && seriesScope.symbolOffset;\n  var labelModel = seriesScope && seriesScope.labelModel;\n  var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n  var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n  var cursorStyle = seriesScope && seriesScope.cursorStyle;\n\n  if (!seriesScope || data.hasItemOption) {\n    var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx); // Color must be excluded.\n    // Because symbol provide setColor individually to set fill and stroke\n\n    itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n    hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n    symbolRotate = itemModel.getShallow('symbolRotate');\n    symbolOffset = itemModel.getShallow('symbolOffset');\n    labelModel = itemModel.getModel(normalLabelAccessPath);\n    hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n    hoverAnimation = itemModel.getShallow('hoverAnimation');\n    cursorStyle = itemModel.getShallow('cursor');\n  } else {\n    hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n  }\n\n  var elStyle = symbolPath.style;\n  symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\n  if (symbolOffset) {\n    symbolPath.attr('position', [parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1])]);\n  }\n\n  cursorStyle && symbolPath.attr('cursor', cursorStyle); // PENDING setColor before setStyle!!!\n\n  symbolPath.setColor(color, seriesScope && seriesScope.symbolInnerColor);\n  symbolPath.setStyle(itemStyle);\n  var opacity = data.getItemVisual(idx, 'opacity');\n\n  if (opacity != null) {\n    elStyle.opacity = opacity;\n  }\n\n  var liftZ = data.getItemVisual(idx, 'liftZ');\n  var z2Origin = symbolPath.__z2Origin;\n\n  if (liftZ != null) {\n    if (z2Origin == null) {\n      symbolPath.__z2Origin = symbolPath.z2;\n      symbolPath.z2 += liftZ;\n    }\n  } else if (z2Origin != null) {\n    symbolPath.z2 = z2Origin;\n    symbolPath.__z2Origin = null;\n  }\n\n  var useNameLabel = seriesScope && seriesScope.useNameLabel;\n  graphic.setLabelStyle(elStyle, hoverItemStyle, labelModel, hoverLabelModel, {\n    labelFetcher: seriesModel,\n    labelDataIndex: idx,\n    defaultText: getLabelDefaultText,\n    isRectText: true,\n    autoColor: color\n  }); // Do not execute util needed.\n\n  function getLabelDefaultText(idx, opt) {\n    return useNameLabel ? data.getName(idx) : getDefaultLabel(data, idx);\n  }\n\n  symbolPath.off('mouseover').off('mouseout').off('emphasis').off('normal');\n  symbolPath.hoverStyle = hoverItemStyle; // FIXME\n  // Do not use symbol.trigger('emphasis'), but use symbol.highlight() instead.\n\n  graphic.setHoverStyle(symbolPath);\n  var scale = getScale(symbolSize);\n\n  if (hoverAnimation && seriesModel.isAnimationEnabled()) {\n    var onEmphasis = function () {\n      // Do not support this hover animation util some scenario required.\n      // Animation can only be supported in hover layer when using `el.incremetal`.\n      if (this.incremental) {\n        return;\n      }\n\n      var ratio = scale[1] / scale[0];\n      this.animateTo({\n        scale: [Math.max(scale[0] * 1.1, scale[0] + 3), Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)]\n      }, 400, 'elasticOut');\n    };\n\n    var onNormal = function () {\n      if (this.incremental) {\n        return;\n      }\n\n      this.animateTo({\n        scale: scale\n      }, 400, 'elasticOut');\n    };\n\n    symbolPath.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n};\n/**\n * @param {Function} cb\n * @param {Object} [opt]\n * @param {Object} [opt.keepLabel=true]\n */\n\n\nsymbolProto.fadeOut = function (cb, opt) {\n  var symbolPath = this.childAt(0); // Avoid mistaken hover when fading out\n\n  this.silent = symbolPath.silent = true; // Not show text when animating\n\n  !(opt && opt.keepLabel) && (symbolPath.style.text = null);\n  graphic.updateProps(symbolPath, {\n    style: {\n      opacity: 0\n    },\n    scale: [0, 0]\n  }, this._seriesModel, this.dataIndex, cb);\n};\n\nzrUtil.inherits(SymbolClz, graphic.Group);\nvar _default = SymbolClz;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_echarts@4.1.0@echarts/lib/chart/helper/Symbol.js\n// module id = d2Vn\n// module chunks = 0","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar createListFromArray = require(\"../helper/createListFromArray\");\n\nvar SeriesModel = require(\"../../model/Series\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _default = SeriesModel.extend({\n  type: 'series.line',\n  dependencies: ['grid', 'polar'],\n  getInitialData: function (option, ecModel) {\n    return createListFromArray(this.getSource(), this);\n  },\n  defaultOption: {\n    zlevel: 0,\n    z: 2,\n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // stack: null\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // polarIndex: 0,\n    // If clip the overflow value\n    clipOverflow: true,\n    // cursor: null,\n    label: {\n      position: 'top'\n    },\n    // itemStyle: {\n    // },\n    lineStyle: {\n      width: 2,\n      type: 'solid'\n    },\n    // areaStyle: {\n    // origin of areaStyle. Valid values:\n    // `'auto'/null/undefined`: from axisLine to data\n    // `'start'`: from min to data\n    // `'end'`: from data to max\n    // origin: 'auto'\n    // },\n    // false, 'start', 'end', 'middle'\n    step: false,\n    // Disabled if step is true\n    smooth: false,\n    smoothMonotone: null,\n    symbol: 'emptyCircle',\n    symbolSize: 4,\n    symbolRotate: null,\n    showSymbol: true,\n    // `false`: follow the label interval strategy.\n    // `true`: show all symbols.\n    // `'auto'`: If possible, show all symbols, otherwise\n    //           follow the label interval strategy.\n    showAllSymbol: 'auto',\n    // Whether to connect break point.\n    connectNulls: false,\n    // Sampling for large data. Can be: 'average', 'max', 'min', 'sum'.\n    sampling: 'none',\n    animationEasing: 'linear',\n    // Disable progressive\n    progressive: 0,\n    hoverLayerThreshold: Infinity\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_echarts@4.1.0@echarts/lib/chart/line/LineSeries.js\n// module id = dP6I\n// module chunks = 0","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar _number = require(\"../util/number\");\n\nvar parsePercent = _number.parsePercent;\n\nvar _dataStackHelper = require(\"../data/helper/dataStackHelper\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;\n}\n\nfunction getAxisKey(axis) {\n  return axis.dim;\n}\n/**\n * @param {string} seriesType\n * @param {module:echarts/model/Global} ecModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\nfunction barLayoutPolar(seriesType, ecModel, api) {\n  var width = api.getWidth();\n  var height = api.getHeight();\n  var lastStackCoords = {};\n  var barWidthAndOffset = calRadialBar(zrUtil.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {\n    return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'polar';\n  }));\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    // Check series coordinate, do layout for polar only\n    if (seriesModel.coordinateSystem.type !== 'polar') {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var polar = seriesModel.coordinateSystem;\n    var baseAxis = polar.getBaseAxis();\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    var valueAxis = polar.getOtherAxis(baseAxis);\n    var center = seriesModel.get('center') || ['50%', '50%'];\n    var cx = parsePercent(center[0], width);\n    var cy = parsePercent(center[1], height);\n    var barMinHeight = seriesModel.get('barMinHeight') || 0;\n    var barMinAngle = seriesModel.get('barMinAngle') || 0;\n    lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n    var valueDim = data.mapDimension(valueAxis.dim);\n    var baseDim = data.mapDimension(baseAxis.dim);\n    var stacked = isDimensionStacked(data, valueDim\n    /*, baseDim*/\n    );\n    var valueAxisStart = valueAxis.getExtent()[0];\n\n    for (var idx = 0, len = data.count(); idx < len; idx++) {\n      var value = data.get(valueDim, idx);\n      var baseValue = data.get(baseDim, idx);\n\n      if (isNaN(value)) {\n        continue;\n      }\n\n      var sign = value >= 0 ? 'p' : 'n';\n      var baseCoord = valueAxisStart; // Because of the barMinHeight, we can not use the value in\n      // stackResultDimension directly.\n      // Only ordinal axis can be stacked.\n\n      if (stacked) {\n        if (!lastStackCoords[stackId][baseValue]) {\n          lastStackCoords[stackId][baseValue] = {\n            p: valueAxisStart,\n            // Positive stack\n            n: valueAxisStart // Negative stack\n\n          };\n        } // Should also consider #4243\n\n\n        baseCoord = lastStackCoords[stackId][baseValue][sign];\n      }\n\n      var r0;\n      var r;\n      var startAngle;\n      var endAngle; // radial sector\n\n      if (valueAxis.dim === 'radius') {\n        var radiusSpan = valueAxis.dataToRadius(value) - valueAxisStart;\n        var angle = baseAxis.dataToAngle(baseValue);\n\n        if (Math.abs(radiusSpan) < barMinHeight) {\n          radiusSpan = (radiusSpan < 0 ? -1 : 1) * barMinHeight;\n        }\n\n        r0 = baseCoord;\n        r = baseCoord + radiusSpan;\n        startAngle = angle - columnOffset;\n        endAngle = startAngle - columnWidth;\n        stacked && (lastStackCoords[stackId][baseValue][sign] = r);\n      } // tangential sector\n      else {\n          // angleAxis must be clamped.\n          var angleSpan = valueAxis.dataToAngle(value, true) - valueAxisStart;\n          var radius = baseAxis.dataToRadius(baseValue);\n\n          if (Math.abs(angleSpan) < barMinAngle) {\n            angleSpan = (angleSpan < 0 ? -1 : 1) * barMinAngle;\n          }\n\n          r0 = radius + columnOffset;\n          r = r0 + columnWidth;\n          startAngle = baseCoord;\n          endAngle = baseCoord + angleSpan; // if the previous stack is at the end of the ring,\n          // add a round to differentiate it from origin\n          // var extent = angleAxis.getExtent();\n          // var stackCoord = angle;\n          // if (stackCoord === extent[0] && value > 0) {\n          //     stackCoord = extent[1];\n          // }\n          // else if (stackCoord === extent[1] && value < 0) {\n          //     stackCoord = extent[0];\n          // }\n\n          stacked && (lastStackCoords[stackId][baseValue][sign] = endAngle);\n        }\n\n      data.setItemLayout(idx, {\n        cx: cx,\n        cy: cy,\n        r0: r0,\n        r: r,\n        // Consider that positive angle is anti-clockwise,\n        // while positive radian of sector is clockwise\n        startAngle: -startAngle * Math.PI / 180,\n        endAngle: -endAngle * Math.PI / 180\n      });\n    }\n  }, this);\n}\n/**\n * Calculate bar width and offset for radial bar charts\n */\n\n\nfunction calRadialBar(barSeries, api) {\n  // Columns info on each category axis. Key is polar name\n  var columnsMap = {};\n  zrUtil.each(barSeries, function (seriesModel, idx) {\n    var data = seriesModel.getData();\n    var polar = seriesModel.coordinateSystem;\n    var baseAxis = polar.getBaseAxis();\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    var columnsOnAxis = columnsMap[getAxisKey(baseAxis)] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: '20%',\n      gap: '30%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[getAxisKey(baseAxis)] = columnsOnAxis;\n    var stackId = getSeriesStackId(seriesModel);\n\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    };\n    var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n\n    if (barWidth && !stacks[stackId].width) {\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      stacks[stackId].width = barWidth;\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    barGap != null && (columnsOnAxis.gap = barGap);\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth\n\n    zrUtil.each(stacks, function (column, stack) {\n      var maxWidth = column.maxWidth;\n\n      if (maxWidth && maxWidth < autoWidth) {\n        maxWidth = Math.min(maxWidth, remainedWidth);\n\n        if (column.width) {\n          maxWidth = Math.min(maxWidth, column.width);\n        }\n\n        remainedWidth -= maxWidth;\n        column.width = maxWidth;\n        autoWidthCount--;\n      }\n    }); // Recalculate width again\n\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    zrUtil.each(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n\n    var offset = -widthSum / 2;\n    zrUtil.each(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\n\nvar _default = barLayoutPolar;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_echarts@4.1.0@echarts/lib/layout/barPolar.js\n// module id = f4MR\n// module chunks = 0","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Polar = require(\"./Polar\");\n\nvar _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\n\nvar _axisHelper = require(\"../../coord/axisHelper\");\n\nvar createScaleByModel = _axisHelper.createScaleByModel;\nvar niceScaleExtent = _axisHelper.niceScaleExtent;\n\nvar CoordinateSystem = require(\"../../CoordinateSystem\");\n\nvar _dataStackHelper = require(\"../../data/helper/dataStackHelper\");\n\nvar getStackedDimension = _dataStackHelper.getStackedDimension;\n\nrequire(\"./PolarModel\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// TODO Axis scale\n\n/**\n * Resize method bound to the polar\n * @param {module:echarts/coord/polar/PolarModel} polarModel\n * @param {module:echarts/ExtensionAPI} api\n */\nfunction resizePolar(polar, polarModel, api) {\n  var center = polarModel.get('center');\n  var width = api.getWidth();\n  var height = api.getHeight();\n  polar.cx = parsePercent(center[0], width);\n  polar.cy = parsePercent(center[1], height);\n  var radiusAxis = polar.getRadiusAxis();\n  var size = Math.min(width, height) / 2;\n  var radius = parsePercent(polarModel.get('radius'), size);\n  radiusAxis.inverse ? radiusAxis.setExtent(radius, 0) : radiusAxis.setExtent(0, radius);\n}\n/**\n * Update polar\n */\n\n\nfunction updatePolarScale(ecModel, api) {\n  var polar = this;\n  var angleAxis = polar.getAngleAxis();\n  var radiusAxis = polar.getRadiusAxis(); // Reset scale\n\n  angleAxis.scale.setExtent(Infinity, -Infinity);\n  radiusAxis.scale.setExtent(Infinity, -Infinity);\n  ecModel.eachSeries(function (seriesModel) {\n    if (seriesModel.coordinateSystem === polar) {\n      var data = seriesModel.getData();\n      zrUtil.each(data.mapDimension('radius', true), function (dim) {\n        radiusAxis.scale.unionExtentFromData(data, getStackedDimension(data, dim));\n      });\n      zrUtil.each(data.mapDimension('angle', true), function (dim) {\n        angleAxis.scale.unionExtentFromData(data, getStackedDimension(data, dim));\n      });\n    }\n  });\n  niceScaleExtent(angleAxis.scale, angleAxis.model);\n  niceScaleExtent(radiusAxis.scale, radiusAxis.model); // Fix extent of category angle axis\n\n  if (angleAxis.type === 'category' && !angleAxis.onBand) {\n    var extent = angleAxis.getExtent();\n    var diff = 360 / angleAxis.scale.count();\n    angleAxis.inverse ? extent[1] += diff : extent[1] -= diff;\n    angleAxis.setExtent(extent[0], extent[1]);\n  }\n}\n/**\n * Set common axis properties\n * @param {module:echarts/coord/polar/AngleAxis|module:echarts/coord/polar/RadiusAxis}\n * @param {module:echarts/coord/polar/AxisModel}\n * @inner\n */\n\n\nfunction setAxis(axis, axisModel) {\n  axis.type = axisModel.get('type');\n  axis.scale = createScaleByModel(axisModel);\n  axis.onBand = axisModel.get('boundaryGap') && axis.type === 'category';\n  axis.inverse = axisModel.get('inverse');\n\n  if (axisModel.mainType === 'angleAxis') {\n    axis.inverse ^= axisModel.get('clockwise');\n    var startAngle = axisModel.get('startAngle');\n    axis.setExtent(startAngle, startAngle + (axis.inverse ? -360 : 360));\n  } // Inject axis instance\n\n\n  axisModel.axis = axis;\n  axis.model = axisModel;\n}\n\nvar polarCreator = {\n  dimensions: Polar.prototype.dimensions,\n  create: function (ecModel, api) {\n    var polarList = [];\n    ecModel.eachComponent('polar', function (polarModel, idx) {\n      var polar = new Polar(idx); // Inject resize and update method\n\n      polar.update = updatePolarScale;\n      var radiusAxis = polar.getRadiusAxis();\n      var angleAxis = polar.getAngleAxis();\n      var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n      var angleAxisModel = polarModel.findAxisModel('angleAxis');\n      setAxis(radiusAxis, radiusAxisModel);\n      setAxis(angleAxis, angleAxisModel);\n      resizePolar(polar, polarModel, api);\n      polarList.push(polar);\n      polarModel.coordinateSystem = polar;\n      polar.model = polarModel;\n    }); // Inject coordinateSystem to series\n\n    ecModel.eachSeries(function (seriesModel) {\n      if (seriesModel.get('coordinateSystem') === 'polar') {\n        var polarModel = ecModel.queryComponents({\n          mainType: 'polar',\n          index: seriesModel.get('polarIndex'),\n          id: seriesModel.get('polarId')\n        })[0];\n        seriesModel.coordinateSystem = polarModel.coordinateSystem;\n      }\n    });\n    return polarList;\n  }\n};\nCoordinateSystem.register('polar', polarCreator);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_echarts@4.1.0@echarts/lib/coord/polar/polarCreator.js\n// module id = jMVH\n// module chunks = 0","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Axis = require(\"../Axis\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction RadiusAxis(scale, radiusExtent) {\n  Axis.call(this, 'radius', scale, radiusExtent);\n  /**\n   * Axis type\n   *  - 'category'\n   *  - 'value'\n   *  - 'time'\n   *  - 'log'\n   * @type {string}\n   */\n\n  this.type = 'category';\n}\n\nRadiusAxis.prototype = {\n  constructor: RadiusAxis,\n\n  /**\n   * @override\n   */\n  pointToData: function (point, clamp) {\n    return this.polar.pointToData(point, clamp)[this.dim === 'radius' ? 0 : 1];\n  },\n  dataToRadius: Axis.prototype.dataToCoord,\n  radiusToData: Axis.prototype.coordToData\n};\nzrUtil.inherits(RadiusAxis, Axis);\nvar _default = RadiusAxis;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_echarts@4.1.0@echarts/lib/coord/polar/RadiusAxis.js\n// module id = jOR4\n// module chunks = 0","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar AxisBuilder = require(\"./AxisBuilder\");\n\nvar AxisView = require(\"./AxisView\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];\nvar selfBuilderAttrs = ['splitLine', 'splitArea'];\n\nvar _default = AxisView.extend({\n  type: 'radiusAxis',\n  axisPointerClass: 'PolarAxisPointer',\n  render: function (radiusAxisModel, ecModel) {\n    this.group.removeAll();\n\n    if (!radiusAxisModel.get('show')) {\n      return;\n    }\n\n    var radiusAxis = radiusAxisModel.axis;\n    var polar = radiusAxis.polar;\n    var angleAxis = polar.getAngleAxis();\n    var ticksCoords = radiusAxis.getTicksCoords();\n    var axisAngle = angleAxis.getExtent()[0];\n    var radiusExtent = radiusAxis.getExtent();\n    var layout = layoutAxis(polar, radiusAxisModel, axisAngle);\n    var axisBuilder = new AxisBuilder(radiusAxisModel, layout);\n    zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n    this.group.add(axisBuilder.getGroup());\n    zrUtil.each(selfBuilderAttrs, function (name) {\n      if (radiusAxisModel.get(name + '.show') && !radiusAxis.scale.isBlank()) {\n        this['_' + name](radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords);\n      }\n    }, this);\n  },\n\n  /**\n   * @private\n   */\n  _splitLine: function (radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {\n    var splitLineModel = radiusAxisModel.getModel('splitLine');\n    var lineStyleModel = splitLineModel.getModel('lineStyle');\n    var lineColors = lineStyleModel.get('color');\n    var lineCount = 0;\n    lineColors = lineColors instanceof Array ? lineColors : [lineColors];\n    var splitLines = [];\n\n    for (var i = 0; i < ticksCoords.length; i++) {\n      var colorIndex = lineCount++ % lineColors.length;\n      splitLines[colorIndex] = splitLines[colorIndex] || [];\n      splitLines[colorIndex].push(new graphic.Circle({\n        shape: {\n          cx: polar.cx,\n          cy: polar.cy,\n          r: ticksCoords[i].coord\n        },\n        silent: true\n      }));\n    } // Simple optimization\n    // Batching the lines if color are the same\n\n\n    for (var i = 0; i < splitLines.length; i++) {\n      this.group.add(graphic.mergePath(splitLines[i], {\n        style: zrUtil.defaults({\n          stroke: lineColors[i % lineColors.length],\n          fill: null\n        }, lineStyleModel.getLineStyle()),\n        silent: true\n      }));\n    }\n  },\n\n  /**\n   * @private\n   */\n  _splitArea: function (radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {\n    if (!ticksCoords.length) {\n      return;\n    }\n\n    var splitAreaModel = radiusAxisModel.getModel('splitArea');\n    var areaStyleModel = splitAreaModel.getModel('areaStyle');\n    var areaColors = areaStyleModel.get('color');\n    var lineCount = 0;\n    areaColors = areaColors instanceof Array ? areaColors : [areaColors];\n    var splitAreas = [];\n    var prevRadius = ticksCoords[0].coord;\n\n    for (var i = 1; i < ticksCoords.length; i++) {\n      var colorIndex = lineCount++ % areaColors.length;\n      splitAreas[colorIndex] = splitAreas[colorIndex] || [];\n      splitAreas[colorIndex].push(new graphic.Sector({\n        shape: {\n          cx: polar.cx,\n          cy: polar.cy,\n          r0: prevRadius,\n          r: ticksCoords[i].coord,\n          startAngle: 0,\n          endAngle: Math.PI * 2\n        },\n        silent: true\n      }));\n      prevRadius = ticksCoords[i].coord;\n    } // Simple optimization\n    // Batching the lines if color are the same\n\n\n    for (var i = 0; i < splitAreas.length; i++) {\n      this.group.add(graphic.mergePath(splitAreas[i], {\n        style: zrUtil.defaults({\n          fill: areaColors[i % areaColors.length]\n        }, areaStyleModel.getAreaStyle()),\n        silent: true\n      }));\n    }\n  }\n});\n/**\n * @inner\n */\n\n\nfunction layoutAxis(polar, radiusAxisModel, axisAngle) {\n  return {\n    position: [polar.cx, polar.cy],\n    rotation: axisAngle / 180 * Math.PI,\n    labelDirection: -1,\n    tickDirection: -1,\n    nameDirection: 1,\n    labelRotate: radiusAxisModel.getModel('axisLabel').get('rotate'),\n    // Over splitLine and splitArea\n    z2: 1\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_echarts@4.1.0@echarts/lib/component/axis/RadiusAxisView.js\n// module id = jPW0\n// module chunks = 0","/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction _default(seriesType, defaultSymbolType, legendSymbol) {\n  // Encoding visual for all series include which is filtered for legend drawing\n  return {\n    seriesType: seriesType,\n    // For legend.\n    performRawSeries: true,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n      var symbolSize = seriesModel.get('symbolSize');\n      var keepAspect = seriesModel.get('symbolKeepAspect');\n      data.setVisual({\n        legendSymbol: legendSymbol || symbolType,\n        symbol: symbolType,\n        symbolSize: symbolSize,\n        symbolKeepAspect: keepAspect\n      }); // Only visible series has each data be visual encoded\n\n      if (ecModel.isSeriesFiltered(seriesModel)) {\n        return;\n      }\n\n      var hasCallback = typeof symbolSize === 'function';\n\n      function dataEach(data, idx) {\n        if (typeof symbolSize === 'function') {\n          var rawValue = seriesModel.getRawValue(idx); // FIXME\n\n          var params = seriesModel.getDataParams(idx);\n          data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n        }\n\n        if (data.hasItemOption) {\n          var itemModel = data.getItemModel(idx);\n          var itemSymbolType = itemModel.getShallow('symbol', true);\n          var itemSymbolSize = itemModel.getShallow('symbolSize', true);\n          var itemSymbolKeepAspect = itemModel.getShallow('symbolKeepAspect', true); // If has item symbol\n\n          if (itemSymbolType != null) {\n            data.setItemVisual(idx, 'symbol', itemSymbolType);\n          }\n\n          if (itemSymbolSize != null) {\n            // PENDING Transform symbolSize ?\n            data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n          }\n\n          if (itemSymbolKeepAspect != null) {\n            data.setItemVisual(idx, 'symbolKeepAspect', itemSymbolKeepAspect);\n          }\n        }\n      }\n\n      return {\n        dataEach: data.hasItemOption || hasCallback ? dataEach : null\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_echarts@4.1.0@echarts/lib/visual/symbol.js\n// module id = kuK2\n// module chunks = 0","var RadiusAxis = require(\"./RadiusAxis\");\n\nvar AngleAxis = require(\"./AngleAxis\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @module echarts/coord/polar/Polar\n */\n\n/**\n * @alias {module:echarts/coord/polar/Polar}\n * @constructor\n * @param {string} name\n */\nvar Polar = function (name) {\n  /**\n   * @type {string}\n   */\n  this.name = name || '';\n  /**\n   * x of polar center\n   * @type {number}\n   */\n\n  this.cx = 0;\n  /**\n   * y of polar center\n   * @type {number}\n   */\n\n  this.cy = 0;\n  /**\n   * @type {module:echarts/coord/polar/RadiusAxis}\n   * @private\n   */\n\n  this._radiusAxis = new RadiusAxis();\n  /**\n   * @type {module:echarts/coord/polar/AngleAxis}\n   * @private\n   */\n\n  this._angleAxis = new AngleAxis();\n  this._radiusAxis.polar = this._angleAxis.polar = this;\n};\n\nPolar.prototype = {\n  type: 'polar',\n  axisPointerEnabled: true,\n  constructor: Polar,\n\n  /**\n   * @param {Array.<string>}\n   * @readOnly\n   */\n  dimensions: ['radius', 'angle'],\n\n  /**\n   * @type {module:echarts/coord/PolarModel}\n   */\n  model: null,\n\n  /**\n   * If contain coord\n   * @param {Array.<number>} point\n   * @return {boolean}\n   */\n  containPoint: function (point) {\n    var coord = this.pointToCoord(point);\n    return this._radiusAxis.contain(coord[0]) && this._angleAxis.contain(coord[1]);\n  },\n\n  /**\n   * If contain data\n   * @param {Array.<number>} data\n   * @return {boolean}\n   */\n  containData: function (data) {\n    return this._radiusAxis.containData(data[0]) && this._angleAxis.containData(data[1]);\n  },\n\n  /**\n   * @param {string} dim\n   * @return {module:echarts/coord/polar/AngleAxis|module:echarts/coord/polar/RadiusAxis}\n   */\n  getAxis: function (dim) {\n    return this['_' + dim + 'Axis'];\n  },\n\n  /**\n   * @return {Array.<module:echarts/coord/Axis>}\n   */\n  getAxes: function () {\n    return [this._radiusAxis, this._angleAxis];\n  },\n\n  /**\n   * Get axes by type of scale\n   * @param {string} scaleType\n   * @return {module:echarts/coord/polar/AngleAxis|module:echarts/coord/polar/RadiusAxis}\n   */\n  getAxesByScale: function (scaleType) {\n    var axes = [];\n    var angleAxis = this._angleAxis;\n    var radiusAxis = this._radiusAxis;\n    angleAxis.scale.type === scaleType && axes.push(angleAxis);\n    radiusAxis.scale.type === scaleType && axes.push(radiusAxis);\n    return axes;\n  },\n\n  /**\n   * @return {module:echarts/coord/polar/AngleAxis}\n   */\n  getAngleAxis: function () {\n    return this._angleAxis;\n  },\n\n  /**\n   * @return {module:echarts/coord/polar/RadiusAxis}\n   */\n  getRadiusAxis: function () {\n    return this._radiusAxis;\n  },\n\n  /**\n   * @param {module:echarts/coord/polar/Axis}\n   * @return {module:echarts/coord/polar/Axis}\n   */\n  getOtherAxis: function (axis) {\n    var angleAxis = this._angleAxis;\n    return axis === angleAxis ? this._radiusAxis : angleAxis;\n  },\n\n  /**\n   * Base axis will be used on stacking.\n   *\n   * @return {module:echarts/coord/polar/Axis}\n   */\n  getBaseAxis: function () {\n    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAngleAxis();\n  },\n\n  /**\n   * @param {string} [dim] 'radius' or 'angle' or 'auto' or null/undefined\n   * @return {Object} {baseAxes: [], otherAxes: []}\n   */\n  getTooltipAxes: function (dim) {\n    var baseAxis = dim != null && dim !== 'auto' ? this.getAxis(dim) : this.getBaseAxis();\n    return {\n      baseAxes: [baseAxis],\n      otherAxes: [this.getOtherAxis(baseAxis)]\n    };\n  },\n\n  /**\n   * Convert a single data item to (x, y) point.\n   * Parameter data is an array which the first element is radius and the second is angle\n   * @param {Array.<number>} data\n   * @param {boolean} [clamp=false]\n   * @return {Array.<number>}\n   */\n  dataToPoint: function (data, clamp) {\n    return this.coordToPoint([this._radiusAxis.dataToRadius(data[0], clamp), this._angleAxis.dataToAngle(data[1], clamp)]);\n  },\n\n  /**\n   * Convert a (x, y) point to data\n   * @param {Array.<number>} point\n   * @param {boolean} [clamp=false]\n   * @return {Array.<number>}\n   */\n  pointToData: function (point, clamp) {\n    var coord = this.pointToCoord(point);\n    return [this._radiusAxis.radiusToData(coord[0], clamp), this._angleAxis.angleToData(coord[1], clamp)];\n  },\n\n  /**\n   * Convert a (x, y) point to (radius, angle) coord\n   * @param {Array.<number>} point\n   * @return {Array.<number>}\n   */\n  pointToCoord: function (point) {\n    var dx = point[0] - this.cx;\n    var dy = point[1] - this.cy;\n    var angleAxis = this.getAngleAxis();\n    var extent = angleAxis.getExtent();\n    var minAngle = Math.min(extent[0], extent[1]);\n    var maxAngle = Math.max(extent[0], extent[1]); // Fix fixed extent in polarCreator\n    // FIXME\n\n    angleAxis.inverse ? minAngle = maxAngle - 360 : maxAngle = minAngle + 360;\n    var radius = Math.sqrt(dx * dx + dy * dy);\n    dx /= radius;\n    dy /= radius;\n    var radian = Math.atan2(-dy, dx) / Math.PI * 180; // move to angleExtent\n\n    var dir = radian < minAngle ? 1 : -1;\n\n    while (radian < minAngle || radian > maxAngle) {\n      radian += dir * 360;\n    }\n\n    return [radius, radian];\n  },\n\n  /**\n   * Convert a (radius, angle) coord to (x, y) point\n   * @param {Array.<number>} coord\n   * @return {Array.<number>}\n   */\n  coordToPoint: function (coord) {\n    var radius = coord[0];\n    var radian = coord[1] / 180 * Math.PI;\n    var x = Math.cos(radian) * radius + this.cx; // Inverse the y\n\n    var y = -Math.sin(radian) * radius + this.cy;\n    return [x, y];\n  }\n};\nvar _default = Polar;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_echarts@4.1.0@echarts/lib/coord/polar/Polar.js\n// module id = qs+o\n// module chunks = 0","var formatUtil = require(\"../../util/format\");\n\nvar BaseAxisPointer = require(\"./BaseAxisPointer\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar viewHelper = require(\"./viewHelper\");\n\nvar matrix = require(\"zrender/lib/core/matrix\");\n\nvar AxisBuilder = require(\"../axis/AxisBuilder\");\n\nvar AxisView = require(\"../axis/AxisView\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar PolarAxisPointer = BaseAxisPointer.extend({\n  /**\n   * @override\n   */\n  makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {\n    var axis = axisModel.axis;\n\n    if (axis.dim === 'angle') {\n      this.animationThreshold = Math.PI / 18;\n    }\n\n    var polar = axis.polar;\n    var otherAxis = polar.getOtherAxis(axis);\n    var otherExtent = otherAxis.getExtent();\n    var coordValue;\n    coordValue = axis['dataTo' + formatUtil.capitalFirst(axis.dim)](value);\n    var axisPointerType = axisPointerModel.get('type');\n\n    if (axisPointerType && axisPointerType !== 'none') {\n      var elStyle = viewHelper.buildElStyle(axisPointerModel);\n      var pointerOption = pointerShapeBuilder[axisPointerType](axis, polar, coordValue, otherExtent, elStyle);\n      pointerOption.style = elStyle;\n      elOption.graphicKey = pointerOption.type;\n      elOption.pointer = pointerOption;\n    }\n\n    var labelMargin = axisPointerModel.get('label.margin');\n    var labelPos = getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin);\n    viewHelper.buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos);\n  } // Do not support handle, utill any user requires it.\n\n});\n\nfunction getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin) {\n  var axis = axisModel.axis;\n  var coord = axis.dataToCoord(value);\n  var axisAngle = polar.getAngleAxis().getExtent()[0];\n  axisAngle = axisAngle / 180 * Math.PI;\n  var radiusExtent = polar.getRadiusAxis().getExtent();\n  var position;\n  var align;\n  var verticalAlign;\n\n  if (axis.dim === 'radius') {\n    var transform = matrix.create();\n    matrix.rotate(transform, transform, axisAngle);\n    matrix.translate(transform, transform, [polar.cx, polar.cy]);\n    position = graphic.applyTransform([coord, -labelMargin], transform);\n    var labelRotation = axisModel.getModel('axisLabel').get('rotate') || 0;\n    var labelLayout = AxisBuilder.innerTextLayout(axisAngle, labelRotation * Math.PI / 180, -1);\n    align = labelLayout.textAlign;\n    verticalAlign = labelLayout.textVerticalAlign;\n  } else {\n    // angle axis\n    var r = radiusExtent[1];\n    position = polar.coordToPoint([r + labelMargin, coord]);\n    var cx = polar.cx;\n    var cy = polar.cy;\n    align = Math.abs(position[0] - cx) / r < 0.3 ? 'center' : position[0] > cx ? 'left' : 'right';\n    verticalAlign = Math.abs(position[1] - cy) / r < 0.3 ? 'middle' : position[1] > cy ? 'top' : 'bottom';\n  }\n\n  return {\n    position: position,\n    align: align,\n    verticalAlign: verticalAlign\n  };\n}\n\nvar pointerShapeBuilder = {\n  line: function (axis, polar, coordValue, otherExtent, elStyle) {\n    return axis.dim === 'angle' ? {\n      type: 'Line',\n      shape: viewHelper.makeLineShape(polar.coordToPoint([otherExtent[0], coordValue]), polar.coordToPoint([otherExtent[1], coordValue]))\n    } : {\n      type: 'Circle',\n      shape: {\n        cx: polar.cx,\n        cy: polar.cy,\n        r: coordValue\n      }\n    };\n  },\n  shadow: function (axis, polar, coordValue, otherExtent, elStyle) {\n    var bandWidth = Math.max(1, axis.getBandWidth());\n    var radian = Math.PI / 180;\n    return axis.dim === 'angle' ? {\n      type: 'Sector',\n      shape: viewHelper.makeSectorShape(polar.cx, polar.cy, otherExtent[0], otherExtent[1], // In ECharts y is negative if angle is positive\n      (-coordValue - bandWidth / 2) * radian, (-coordValue + bandWidth / 2) * radian)\n    } : {\n      type: 'Sector',\n      shape: viewHelper.makeSectorShape(polar.cx, polar.cy, coordValue - bandWidth / 2, coordValue + bandWidth / 2, 0, Math.PI * 2)\n    };\n  }\n};\nAxisView.registerAxisPointerClass('PolarAxisPointer', PolarAxisPointer);\nvar _default = PolarAxisPointer;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_echarts@4.1.0@echarts/lib/component/axisPointer/PolarAxisPointer.js\n// module id = rlNm\n// module chunks = 0","<template>\r\n<v-chart :options=\"polar\"/>\r\n</template>\r\n\r\n<style>\r\n/**\r\n * The default size is 600px400px, for responsive charts\r\n * you may need to set percentage values as follows (also\r\n * don't forget to provide a size for the container).\r\n */\r\n.echarts {\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n</style>\r\n\r\n<script>\r\nimport ECharts from 'vue-echarts'\r\nimport 'echarts/lib/chart/line'\r\nimport 'echarts/lib/component/polar'\r\n\r\nexport default {\r\n  components: {\r\n    'v-chart': ECharts\r\n  },\r\n  data () {\r\n    let data = []\r\n\r\n    for (let i = 0; i <= 360; i++) {\r\n        let t = i / 180 * Math.PI\r\n        let r = Math.sin(2 * t) * Math.cos(2 * t)\r\n        data.push([r, i])\r\n    }\r\n\r\n    return {\r\n      polar: {\r\n        title: {\r\n          text: ''\r\n        },\r\n        legend: {\r\n          data: ['line']\r\n        },\r\n        polar: {\r\n          center: ['50%', '54%']\r\n        },\r\n        tooltip: {\r\n          trigger: 'axis',\r\n          axisPointer: {\r\n            type: 'cross'\r\n          }\r\n        },\r\n        angleAxis: {\r\n          type: 'value',\r\n          startAngle: 0\r\n        },\r\n        radiusAxis: {\r\n          min: 0\r\n        },\r\n        series: [\r\n          {\r\n            coordinateSystem: 'polar',\r\n            name: 'line',\r\n            type: 'line',\r\n            showSymbol: false,\r\n            data: data\r\n          }\r\n        ],\r\n        animationDuration: 2000\r\n      }\r\n    }\r\n  }\r\n}\r\n</script>\n\n\n// WEBPACK FOOTER //\n// src/view/ECharts/EChartsOne.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('v-chart',{attrs:{\"options\":_vm.polar}})}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_vue-loader@13.7.3@vue-loader/lib/template-compiler?{\"id\":\"data-v-509d19c9\",\"hasScoped\":false,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/_vue-loader@13.7.3@vue-loader/lib/selector.js?type=template&index=0!./src/view/ECharts/EChartsOne.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/_extract-text-webpack-plugin@3.0.2@extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true,\\\"publicPath\\\":\\\"../../\\\"}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../../node_modules/_vue-loader@13.7.3@vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-509d19c9\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../../../node_modules/_vue-loader@13.7.3@vue-loader/lib/selector?type=styles&index=0!./EChartsOne.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/_vue-loader@13.7.3@vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../../node_modules/_vue-loader@13.7.3@vue-loader/lib/selector?type=script&index=0!./EChartsOne.vue\"\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/_vue-loader@13.7.3@vue-loader/lib/selector?type=script&index=0!./EChartsOne.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/_vue-loader@13.7.3@vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-509d19c9\\\",\\\"hasScoped\\\":false,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../node_modules/_vue-loader@13.7.3@vue-loader/lib/selector?type=template&index=0!./EChartsOne.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/view/ECharts/EChartsOne.vue\n// module id = null\n// module chunks = "],"sourceRoot":""}